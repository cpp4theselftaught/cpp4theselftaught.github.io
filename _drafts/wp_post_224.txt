ID: 243
post_author: 1
post_date: "2017-08-15 19:21:06"
post_date_gmt: "2017-08-15 23:21:06"
post_content: "Code should clearly express intent.rn<!--more-->rnI could leave it that, and probably would, if coding standards and coding styles were not such controversial subjects: whenever you wade into this subject, it seems can't help but be swept away by a torrent of religious debate over Hungarian notation (<a href="http://rlc.vlinder.ca/blog/2009/08/name-for-functionality-not-type/" target="_blank">a clearly evil phenomenon</a>) and other such nonsense. rnrnI generally don't care much about <code>UpperCamelCase</code> vs. <code>lowerCamelCase</code> vs. <code>snake_style</code> debates -- as long as you're consistent with existing code, do whatever you find easiest to read -- but I do care about two things: how things are named and, more generally, how intent is expressed in code. rnrnAs part of the project, I want to highlight a few things, including how writing expressive code can help avoid common bugs such as buffer overruns, undetected internal inconsistencies in input data, etc. rnrnOne example of expressive code can be found in the DER encoder, where the length of the TLV is encoded as a variable-sized integer. rn[caption id="attachment_241" align="alignnone" width="300"]<a href="http://cpp4theselftaught.com/wp-content/uploads/2017/08/image.jpeg"><img src="http://cpp4theselftaught.com/wp-content/uploads/2017/08/image-300x87.jpeg" alt="Example of expressive code" width="300" height="87" class="size-medium wp-image-241" /></a> Example of expressive code[/caption]rnIn this code, the <code>Details::Integer</code> class encapsulates a particular caveat of DER encoding, in that for unsigned integers the nine leading bits of the encoded integer may never be zero. Similarly, the nine leading bits of a signed integer may neither be all zeroes nor all ones. The <code>Details::Integer</code> class uses the C++ type system to know whether a given integer is signed or unsigned and implements both behaviours accordingly. Most of this is hidden from view from its user, but according to the philosophy that you neither pay for what you don't use, not suffer from unexpected implicit side-effects, the <code>Details::Integer</code> class has a <code>compact</code> method that is explicitly called to trigger this behaviour. An alternative would have been to call <code>compact</code> whenever <code>begin</code> is called, but that would have added an unexpected side-effect to <code>begin</code> in that this method is expected to be an accessor, not a mutator. rnrnAlso note the various assertions made by the code. If at this point in the code any of these assertions fail, something is seriously wrong: the value of the <code>length</code> variable, from which our <code>Details::Integer</code> is constructed, has been determined to be greater than 127, so it will need at least one byte to be encoded. The maximum size that <em>can</em> be encoded in the length field (of the length field) is 127 octets, or 1,016 bits ((That can encode an integer value up to [latex]2^{1016}-1=702,223,880,805,592,151,456,759,840,151,962,786,569,522,257,399,338,504,974,336,254,522,393,264,865,238,137,237,242,489,540,654,437,582,500,44,843,247,630,303,354,647,534,431,314,931,612,685,275,935,445,798,350,655,833,690,880,801,860,555,545,317,367,555,154,113,605,281,582,053,784,524,026,102,900,245,630,757,473,088,050,106,395,169,337,932,361,665,227,499,793,929,447,186,391,815,763,110,662,594,625,535[/latex].)). This is well beyond what can reasonably be expected to be the maximum value of a length field, which we should be able to encode in no more octets the size of the length value being encoded.rnrnThese assertions add to the expressiveness of the code by making it clear that certain things are clearly not expected at this point. It also makes clear that the encoded size of the length is expected to remain less than or equal to the unencoded size the length -- i.e. the overhead of encoding the length should be negative (or no more than one byte in the case of a length of [latex]2^{56}=72,057,594,037,927,900[/latex] octets or more).rnrnFinally, note that while we do copy the integer to the output, we do so using <code>std::copy</code>. There are two reasons for this: firstly, it's much clearer to read "copy the integer the output" when you read <code>out = std::copy(integer_length.begin(), integer_length.end(), out);</code> than when you read <code>for (auto curr(integer_length.begin()); curr != integer_length.end(); ) { *out++ = *curr++; }</code>; and secondly the standard algorithm implementation may know about optimisations that explicitly writing the loop may never know. rnrnSo, expressive code not only leads to fewer bugs and easier-to-maintain code, but may actually lead to more efficient code as well."
post_title: "A note on the expressiveness of code"
post_excerpt: ""
post_status: "inherit"
comment_status: "closed"
ping_status: "closed"
post_password: ""
post_name: "238-revision-v1"
to_ping: ""
pinged: ""
post_modified: "2017-08-15 19:21:06"
post_modified_gmt: "2017-08-15 23:21:06"
post_content_filtered: ""
post_parent: 238
guid: "http://cpp4theselftaught.com/2017/08/238-revision-v1/"
menu_order: 0
post_type: "revision"
post_mime_type: ""
comment_count: 0
