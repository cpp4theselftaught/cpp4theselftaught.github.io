ID: 85
post_author: 1
post_date: "2013-04-03 12:44:50"
post_date_gmt: "2013-04-03 16:44:50"
post_content: "Serializing is the act of taking a chink of data an converting it to something that can be communicated -- i.e. some format or other that someone or something else can parse and understand. You do it all the time when you write, or even when you talk: you serialize your thoughts as words that you then serialize as either characters on paper (virtual or dead tree) or as sound.nnParsing is the opposite process of serializing -- also called deserializing.n<!--more-->nAs with words on paper, there is some inaccuracy in serializing when it's floating point numbers being serialized in human-readable form. That is because a computer uses a binary system for counting while a human uses a decimal system. For integers, that doesn't matter because any integer value that can be represented in, say, 32 bits can also be represented in 10 decimal characters and the conversion is fairly straight-forward.nnThe same is not true of floating point values: due to the way floats are implemented, there are some numbers that simply cannot be accurately represented in a <code>float</code> (the same goes for <code>double</code>s, of course).nnFloating point numbers consist of three parts: the sign (plus or minus), the mantissa and the exponent. The value is [latex]V=S*M*10^E[/latex] in which [latex]S[/latex] is 1 for positive and -1 for negative, [latex]M[/latex] the mantissa and [latex]E[/latex] the exponent. For example, in the case of -12.345 [latex]S = -1[/latex], [latex]E = 1[/latex] and [latex]M = 1.2345[/latex].nnUnderstanding this, we can implement a function to split a floating-point value into its constituent parts: <pre lang="cpp">void split_float(n int *signn , double *mantissan , int *exponentn , double valuen )n{n pre_condition(sign && mantissa && exponent);n if (value < 0)n {n *sign = -1;n value = -value;n }n elsen {n *sign = 1;n }n *exponent = (int)log10(value);n *mantissa = value / pow(10, *exponent);n}</pre>nIn this code, the first thing we take care of is the sign. Note that we also change the sign of <code>value</code> in that case, because <code>log10</code> of a negative number doesn't work.nnTo get the exponent, we call <code>log10</code> on the (now positive) value and round it off. Whether casting to <code>int</code> rounds up or down depends on the machine you run it on (mostly), but it usually tends to round down.nnTo get the mantissa, [latex]M[/latex] we do this: [latex]M=\frac{{\lvert}V{\rvert}}{10^E}[/latex] which is equivalent to hacking off the exponent part of the value, leaving only the mantissa.nnNow, if we want to serialize this into a <code>char</code> buffer, we can write a function like this: <pre lang="cpp">int serialize(n char *outn , unsigned int out_sizen , double valuen )n{n pre_condition(out || !out_size);n int s, e, dotted = 0, outputting = 0, characters = 0;n split_float(&s, &value, &e, value);n if (out_size && (-1 == s))n {n *out++ = '-';n --out_size;n }n elsen { /bin /boot /cdrom /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /libx32 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old not negative */ }nn while (out_size && value && (characters < 15))n {n *out++ = '0' + (int)value;n --out_size;n value -= (int)value;n value *= 10;n ++characters;n if (value && out_size && !dotted)n {n *out++ = '.';n --out_size;n dotted = 1;n }n elsen { /bin /boot /cdrom /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /libx32 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old already dotted or no space for the dot */ }n }n if (out_size && e)n {n *out++ = 'e';n --out_size;n if ((e < 0) && out_size)n {n *out++ = '-';n e = -e;n }n if (out_size && (e / 100))n {n *out++ = '0' + (e / 100);n --out_size;n outputting = 1;n }n elsen { /bin /boot /cdrom /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /libx32 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old no more space or nothing to output */ }n e = e % 100;n if (outputting || (out_size && (e / 10)))n {n *out++ = '0' + (e / 10);n --out_size;n outputting = 1;n }n elsen { /bin /boot /cdrom /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /libx32 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old no more space or nothing to output */ }n e = e % 10;n if (outputting || (out_size && e))n {n *out++ = '0' + e;n --out_size;n }n elsen { /bin /boot /cdrom /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /libx32 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old no more space or nothing to output */ }n }n elsen { /bin /boot /cdrom /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /libx32 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old no exponent or no more space */ }n if (out_size) *out = 0;n return (int)--out_size;n}</pre>nnThere are a few interesting details in this piece of code. Look, for example, how it handles the size of the output buffer: it only writes to <code>*out</code> one character at a time and only if <code>out_size</code> is greater than 0. Note, though, that it decrements <code>out_size</code> unconditionally on the last line. This has the effect of returning the number of bytes remaining in the output buffer on success (which will be >= 0) or -1 on error.nnSimilarly, we know that a <code>double</code> can't have an exponent of more than three characters, so in stead of taking [latex]E \mod 10[/latex] and repeatedly dividing [latex]E[/latex] by 10, then inverting the generated characters (which is the way integers are usually serialized) we just check hundreds, tens and units like a human would normally do.nnLikewise, we know that by dividing [latex]{\lvert}V{\rvert}[/latex] by [latex]10^E[/latex] we are left with [latex]0 \leq M < 10[/latex], so we have one digit before the dot. We can then output the dot immediately after the first digit, unless there's nothing more to output.nnThere's a few other trivial details that new programmers may want to look at -- here's some code to run it with: <pre lang="cpp">int main(void)n{n char buffer[100];n assert(serialize(buffer, sizeof(buffer), -1) == 97);n assert(strcmp("-1", buffer) == 0);n printf("%s\n", buffer);n n #define TEST(a) \n assert(serialize(buffer, sizeof(buffer), a) > 0); \n printf("%s -> %s\n", #a, buffer); n TEST(0.43141910996070e8);n TEST(-0.4948270426510e51);n TEST(0.8017058961133e32);n TEST(-0.6431647334000e-50);n TEST(0.62050295608660e-7);n TEST(-0.7980292076396e43);n TEST(0.8098012295643e-42);n TEST(-0.235788271940e84);n TEST(0.5378916319145e93);n TEST(-0.83169954137327e-3);n n return 0;n}</pre>"
post_title: "Serializing floats"
post_excerpt: ""
post_status: "inherit"
comment_status: "open"
ping_status: "open"
post_password: ""
post_name: "62-revision-23"
to_ping: ""
pinged: ""
post_modified: "2013-04-03 12:44:50"
post_modified_gmt: "2013-04-03 16:44:50"
post_content_filtered: ""
post_parent: 62
guid: "http://cpp4theselftaught.com/2013/04/62-revision-23/"
menu_order: 0
post_type: "revision"
post_mime_type: ""
comment_count: 0
