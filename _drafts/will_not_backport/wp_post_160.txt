ID: 177
post_author: 1
post_date: "2013-09-20 17:58:08"
post_date_gmt: "2013-09-20 22:58:08"
post_content: "n<div class="topsy_widget_data topsy_theme_blue" style="float: right;margin-left: 0.75em; background: url(data:,%7B%20%22url%22%3A%20%22http%253A%252F%252Frlc.vlinder.ca%252Fblog%252F2013%252F09%252Frun-time-composed-predicates-and-code-generation%252F%22%2C%20%22shorturl%22%3A%20%22http%3A%2F%2Fbit.ly%2F1abbN2b%22%2C%20%22style%22%3A%20%22big%22%2C%20%22title%22%3A%20%22Run-time%20composed%20predicates%20and%20Code%20generation%20%23code%20generation%20%23functional%20programming%22%20%7D);"></div>n<p>While working on Arachnida, preparing version 2.2 due out this fall, one of the things we&#8217;ll be introducing is a hardened OpenSSL transport-layer-security plug-in, to replace the one we&#8217;ve had for the last seven or so years. One of the new features in this plug-in (which is part of Arachnida&#8217;s &#8220;Scorpion&#8221; module) is a much more flexible configuration scheme including the subject of today&#8217;s post: run-time composed predicates.</p>n<p><span id="more-2367"></span></p>n<p>As the name indicates, run-time composed predicates are predicates that are composed at run-time. In this case, we use them for post-connection validations of the SSL/TLS connection: the user can plug their own post-connection validations in and combine them with the ones provided in the library using AND, OR, NOR, NAND, XOR and NOT primitives. Typically, such a composed predicate would look like this:</p>n<pre lang="cpp">configuration.post_connection_verification_predicate_ = and_(n and_( peer_provided_certificate__, fqdn_matches_peer__)n , userProvidedPredicate);</pre>n<p>in which <code>userProvidedPredicate</code> is a pointer to a user-provided predicate function whereas the other two predicates are included in the library.</p>n<p>The thing is that each of the following will also work:</p>n<pre lang="cpp">// if the peer provided a predicate, assume everything is finenconfiguration.post_connection_verification_predicate_ = peer_provided_certificate__;n// we accept this only of the FQDN in the peer-provided certificate DOES NOT match the peer's FQDNn// THIS IS STUPID - DO NOT DO THIS IN YOUR CODE!nconfiguration.post_connection_verification_predicate_ = not_(fqdn_matches_peer__);n// apply only the user's predicatenconfiguration.post_connection_verification_predicate_ = userProvidedPredicate;</pre>n<p>The trick here is that the predicate type, <code>PostConnectionVerificationPredicate</code>, is a function-to-pointer type and the functions <code>and_</code>, <code>or_</code>, <code>xor_</code>, <code>nand_</code>, <code>nor_</code> and <code>not_</code> each return a function to a &#8220;newly created&#8221; function.</p>n<p>Of course, C++ does not allow the creation of functions at run-time and, as the call-back is passed to OpenSSL and OpenSSL is written in C, more to the point, neither does C.</p>n<p>As Arachnida is designed to run on industrial control systems and industrial embedded devices, we want to avoid run-time memory allocation if at all possible &#8212; and when that&#8217;s not possible, we want to control it. In this case, we avoid it by creating an array of pointers to functions, another array of &#8220;configurations&#8221; for those functions and a function for each position in the array. We do this using a Perl script (because we usually use Perl to generate code and it integrates nicely with our build system).</p>n<p>The following chunk of code is the generation script verbatim &#8212; annotated.</p>n<p>First, the usual pre-amble code: for the Perl part, this is invoking the interpreter; for the C++ code, this is including the neccessary headers.</p>n<pre lang="perl">#! /usr/bin/env perlnmy $name = $0;nmy $max_predicate_count = 20;nnprint <<EOFn#line 7 "${name}"n#include "Scorpion/OpenSSL/Details/PostConnectionVerificationPredicate.h"n#include <new>n#include <stdexcept>n</pre>n<p>The maximum predicate count is set above, and replicated in the generated C++ source code here. To change it, we currently need to change the script. At some point (probably before version 2.2 of Arachnida is released) this will become a command-line argument to the script.</p>n<pre lang="perl">#define MAX_PREDICATE_COUNT ${max_predicate_count}nnnamespace Scorpion { namespace OpenSSL { namespace Details {nnamespace {n static unsigned int next_predicate_id__ = 0;</pre>n<p>The following is how predicates are allocated: any call to any of the predicate construction functions (<code>and_</code>, <code>or_</code>, etc.) will call this once, and throw <code>bad_alloc</code> if it fails.</p>n<pre lang="perl"> unsigned int allocatePredicateID()n {n if (MAX_PREDICATE_COUNT == next_predicate_id__) throw std::bad_alloc();n return next_predicate_id__++;n }</pre>n<p>The following structure holds the configuration of the &#8220;generated&#8221; predicate. This is all we need to know for any operator: what the left-hand-side of the expression is, what the right-hand-side is and what operator it is. One operator is unary, all the others are binary. The unary one only uses the <code>lhs_</code> member of this structure.</p>n<pre lang="perl"> struct PredicateInfon {n enum Type {n and__n , or__n , xor__n , nand__n , nor__n , not__n };nn Type type_;n PostConnectionVerificationPredicate lhs_;n PostConnectionVerificationPredicate rhs_;n };</pre>n<p>The following is an array of each of these configurations, followed by Perl code to generate each of the functions. I could have used a template to generate these rather than generated code but I find as long as I&#8217;m generating code anyway, it makes more sense to just keep generating &#8212; especially if there&#8217;s no compelling reason to do otherwise.</p>n<pre lang="perl"> PredicateInfo predicate_infos__[MAX_PREDICATE_COUNT];nEOFn;nnfor (my $i = 0; $i < $max_predicate_count; ++$i) {n print <<EOFn#line 46 "${name}"n bool predicate${i}(SSL *ssl, char *host)n {n switch (predicate_infos__[${i}].type_)n {n case PredicateInfo::and__ :n return (predicate_infos__[${i}].lhs_(ssl, host) &#038;&#038; predicate_infos__[${i}].rhs_(ssl, host));n case PredicateInfo::or__ :n return (predicate_infos__[${i}].lhs_(ssl, host) || predicate_infos__[${i}].rhs_(ssl, host));n case PredicateInfo::xor__ :n {n long lhs_result(predicate_infos__[${i}].lhs_(ssl, host));n long rhs_result(predicate_infos__[${i}].rhs_(ssl, host));nn return<sup><a href="http://rlc.vlinder.ca/blog/2013/09/run-time-composed-predicates-and-code-generation/#footnote_0_2367" id="identifier_0_2367" class="footnote-link footnote-identifier-link" title="lhs_result != 0) ^ (rhs_result != 0">1</a></sup>;n }n case PredicateInfo::nand__ :n return !(predicate_infos__[${i}].lhs_(ssl, host) &#038;&#038; predicate_infos__[${i}].rhs_(ssl, host));n case PredicateInfo::nor__ :n return !(predicate_infos__[${i}].lhs_(ssl, host) &#038;&#038; predicate_infos__[${i}].rhs_(ssl, host));n case PredicateInfo::not__ :n return !predicate_infos__[${i}].lhs_(ssl, host);n }n throw std::logic_error("Should not reach this code");n }nEOFn ;n}</pre>n<p>We can now generate the array of function pointers that the operator/generator code will pick from:</p>n<pre lang="perl">print <<EOFn#line 77 "${name}"n PostConnectionVerificationPredicate predicates__[] = {nEOFn;nmy $first = 1;nfor (my $i = 0; $i < $max_predicate_count; ++$i) {n if ($first) {n print <<EOFn#line 84 "${name}"n predicate${i}nEOFn ;n }n else {n print <<EOFn#line 91 "${name}"n , predicate${i}nEOFn ;n }n $first = 0;n}nprint <<EOFn#line 99 "${name}"n };nEOFn ;nnprint <<EOFn#line 105 "${name}"n}nEOFn;</pre>n<p>and create a function for each operator. Not that the binary operators are all the same for all intents and purposes, so might as well generate those too.</p>n<pre lang="perl">my @keywords = qw/and or nor xor nand/;nnforeach $keyword (@keywords) {n print <<EOFn#line 113 "${name}"nPostConnectionVerificationPredicate ${keyword}_(PostConnectionVerificationPredicate lhs, PostConnectionVerificationPredicate rhs)n{n unsigned int predicate_id(allocatePredicateID());n predicate_infos__[predicate_id].type_ = PredicateInfo::${keyword}__;n predicate_infos__[predicate_id].lhs_ = lhs;n predicate_infos__[predicate_id].rhs_ = rhs;n return predicates__[predicate_id];n}nEOFn ;n}nnprint <<EOFn#line 127 "${name}"nPostConnectionVerificationPredicate not_(PostConnectionVerificationPredicate lhs)n{n unsigned int predicate_id(allocatePredicateID());n predicate_infos__[predicate_id].type_ = PredicateInfo::not__;n predicate_infos__[predicate_id].lhs_ = lhs;n predicate_infos__[predicate_id].rhs_ = 0;n return predicates__[predicate_id];n}nn}}}nEOFn;</pre>n<p>A few fun tidbits: the <code>#line</code> directives tell the compiler where to look for the code for stepping etc., so if you step through this code you'll be stepping into Perl!</p>n<p>This approach works for a whole slew of other repetitive code. Generated code, once debugged etc., usually scales pretty well: if I need a thousand of these operators for some reason, I have one constant to change and no other questions to ask (except perhaps why I could possibly need that many predicates!)</p>n<p>I used a very similar approach to translate a dump from the Unicode into C code to parse it: computers are very good at repeating themselves with minor variations in what they're saying. This is an example of how you can reduce the amount of work you do by making the computer do more.</p>nn<ol class="footnotes"><li id="footnote_0_2367" class="footnote">lhs_result != 0) ^ (rhs_result != 0</li></ol>"
post_title: "Run-time composed predicates and Code generation"
post_excerpt: "While working on Arachnida, preparing version 2.2 due out this fall, one of the things we&rsquo;ll be introducing is a hardened OpenSSL transport-layer-security plug-in, to replace the one we&rsquo;ve had for the last seven or so years. One of the &hellip; <a href="http://rlc.vlinder.ca/blog/2013/09/run-time-composed-predicates-and-code-generation/">Continue reading <span>&rarr;</span></a>"
post_status: "inherit"
comment_status: "closed"
ping_status: "closed"
post_password: ""
post_name: "88-revision-v1"
to_ping: ""
pinged: ""
post_modified: "2013-09-20 17:58:08"
post_modified_gmt: "2013-09-20 22:58:08"
post_content_filtered: ""
post_parent: 88
guid: "http://feedwordpress.radgeek.com/?rev=232af3de514a7f248464e26231f2a362"
menu_order: 0
post_type: "revision"
post_mime_type: ""
comment_count: 0
