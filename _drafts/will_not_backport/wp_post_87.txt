ID: 100
post_author: 1
post_date: "2014-01-12 21:34:10"
post_date_gmt: "2014-01-13 02:34:10"
post_content: "n<div class="topsy_widget_data topsy_theme_blue" style="float: right;margin-left: 0.75em; background: url(data:,%7B%20%22url%22%3A%20%22http%253A%252F%252Frlc.vlinder.ca%252Fblog%252F2011%252F06%252Ffunctional-programming-at-compile-time-cpp4theselftaught%252F%22%2C%20%22shorturl%22%3A%20%22http%3A%2F%2Fbit.ly%2FjQz8g7%22%2C%20%22style%22%3A%20%22big%22%2C%20%22title%22%3A%20%22Functional%20Programming%20at%20Compile-Time%22%20%7D);"></div>n<p> <audio id="wp_mep_5" src="http://vlinder.ca/podcasts/31-compile-time-fp.mp3" controls="controls" preload="none" >n n n n n n n n <object width="400" height="30" type="application/x-shockwave-flash" data="http://rlc.vlinder.ca/wp-content/plugins/media-element-html5-video-and-audio-player/mediaelement/flashmediaelement.swf">n <param name="movie" value="http://rlc.vlinder.ca/wp-content/plugins/media-element-html5-video-and-audio-player/mediaelement/flashmediaelement.swf" />n <param name="flashvars" value="controls=true&amp;file=http://vlinder.ca/podcasts/31-compile-time-fp.mp3" /> n </object> n </audio>n<script type="text/javascript">njQuery(document).ready(function($) {n $('#wp_mep_5').mediaelementplayer({n m:1n n ,features: ['playpause','current','progress','duration','volume','tracks','fullscreen']n ,audioWidth:400,audioHeight:30n });n});n</script>nIn the <a href="http://rlc.vlinder.ca/blog/2011/05/using-ranges-and-functional-programming-in-c-cpp4theselftaught/">previous installment</a> I talked about functional programming a bit, introducing the idea of <em>functors</em> and <em>lambda expressions</em>. This time, we will look at another type of functional programming: a type that is done at compile-time.<br />n<span id="more-1503"></span></p>n<h2>Meta-functions</h2>n<p>In functional programming, a function is anything you can call, and it can return anything &#8212; including another function. In meta-programming (programming &#8220;about&#8221; programming), functional programming takes the form of meta-functions returning meta-functions or values. All of this happens at compile-time, which means the values are constants and the meta-functions are types.</p>n<p>One of the simplest possible meta-functions is the <code>identity</code> function, which looks like this:</p>nn<div class="wp_syntax"><table><tr><td class="code"><pre class="cpp" style="font-family:monospace;"><span style="color: #0000ff;">template</span> <span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">typename</span> T <span style="color: #000080;">&gt;</span>n<span style="color: #0000ff;">class</span> identityn<span style="color: #008000;">&#123;</span>n <span style="color: #0000ff;">typedef</span> T type<span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span></pre></td></tr></table></div>nn<p>This meta-function &#8220;returns&#8221; the type passed to it, which would be equivalent to a function that returns the value passed to it, but far more useful. This also allows me to show you a common convention in meta-programming, namely that the return type of a meta-function is usually called <code>type</code> and the return value (if applicable) of a meta-function is called <code>value</code>. Often, a meta-function that returns a value (which must of course be a compile-time constant) also returns a type &#8211; namely itself. That is not strictly needed, though.</p>n<p>Before we dive into the real code, I&#8217;ll tell you what the real code does: it generates a Fibonacci sequence at compile-time, and uses a run-time construct to fill an array with the generated sequence &#8211; and it uses only functional programming techniques (both at compile-time and at run-time) to do so.</p>n<p>A Fibonacci sequence is a sequence of numbers initially meant to model the growth of a population of rabbits, given a fixed generation time and unlimited resources. Each number in the sequence is the sum of the two previous numbers, and the sequence starts with 0, 1. That means that, in the array <code>a</code> we will generate, <code>a[0] = 0; a[1] = 1; a[n] = a[n - 2] + a[n - 1]</code>. This means our meta-function, which calculates the same at compile-time, will look like this:</p>nn<div class="wp_syntax"><table><tr><td class="code"><pre class="cpp" style="font-family:monospace;"><span style="color: #0000ff;">template</span> <span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">int</span> n__ <span style="color: #000080;">&gt;</span>n<span style="color: #0000ff;">struct</span> Fibonacci_n<span style="color: #008000;">&#123;</span>n <span style="color: #0000ff;">enum</span> <span style="color: #008000;">&#123;</span> value <span style="color: #000080;">=</span> Fibonacci_<span style="color: #000080;">&lt;</span> n__ <span style="color: #000040;">-</span> <span style="color: #0000dd;">1</span> <span style="color: #000080;">&gt;</span><span style="color: #008080;">::</span><span style="color: #007788;">value</span> <span style="color: #000040;">+</span> Fibonacci_<span style="color: #000080;">&lt;</span> n__ <span style="color: #000040;">-</span> <span style="color: #0000dd;">2</span> <span style="color: #000080;">&gt;</span><span style="color: #008080;">::</span><span style="color: #007788;">value</span> <span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span>n <span style="color: #0000ff;">typedef</span> Fibonacci_<span style="color: #000080;">&lt;</span> n__ <span style="color: #000040;">-</span> <span style="color: #0000dd;">1</span> <span style="color: #000080;">&gt;</span> next<span style="color: #008080;">;</span>n <span style="color: #0000ff;">typedef</span> Fibonacci_<span style="color: #000080;">&lt;</span> n__ <span style="color: #000080;">&gt;</span> type<span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span>n&nbsp;n<span style="color: #0000ff;">template</span><span style="color: #000080;">&lt;&gt;</span>n<span style="color: #0000ff;">struct</span> Fibonacci_<span style="color: #000080;">&lt;</span><span style="color: #0000dd;">1</span><span style="color: #000080;">&gt;</span>n<span style="color: #008000;">&#123;</span>n <span style="color: #0000ff;">enum</span> <span style="color: #008000;">&#123;</span> value <span style="color: #000080;">=</span> <span style="color: #0000dd;">1</span> <span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span>n <span style="color: #0000ff;">typedef</span> Fibonacci_<span style="color: #000080;">&lt;</span> <span style="color: #0000dd;">1</span> <span style="color: #000080;">&gt;</span> type<span style="color: #008080;">;</span>n <span style="color: #0000ff;">typedef</span> Fibonacci_<span style="color: #000080;">&lt;</span> <span style="color: #0000dd;">0</span> <span style="color: #000080;">&gt;</span> next<span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span>n&nbsp;n<span style="color: #0000ff;">template</span> <span style="color: #000080;">&lt;&gt;</span>n<span style="color: #0000ff;">struct</span> Fibonacci_<span style="color: #000080;">&lt;</span><span style="color: #0000dd;">0</span><span style="color: #000080;">&gt;</span>n<span style="color: #008000;">&#123;</span>n <span style="color: #0000ff;">typedef</span> Fibonacci_<span style="color: #000080;">&lt;</span> <span style="color: #0000dd;">0</span> <span style="color: #000080;">&gt;</span> type<span style="color: #008080;">;</span>n <span style="color: #0000ff;">enum</span> <span style="color: #008000;">&#123;</span> value <span style="color: #000080;">=</span> <span style="color: #0000dd;">0</span> <span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span></pre></td></tr></table></div>nn<p>As you can see, the meta-function is a class (or <code>struct</code> in this case), with an <code>enum</code> and one or more <code>typedef</code>s in it. Sometimes (as we will see later) there are also function declarations, though at compile-time, no run-time functions will actually be called &#8212; and there can also be other other types.</p>n<p>In this case, we have two specializations of our class template: one in which <code>n__</code> is 1, and one in which <code>n__</code> is 0. We need those because for those two values, the resulting value is pre-defined &#8211; not calculated. For all other values of <code>n__</code>, the resulting value is calculated at compile-time by recursively specializing the class template with smaller and smaller values of <code>n__</code>, until we run into 0 and 1.</p>n<p>Compilers are smart: while at run-time, a similar approach would require <img src="http://s0.wp.com/latex.php?latex=2%5En&#038;bg=ffffff&%23038;fg=000&%23038;s=0" alt="2^n" title="2^n" class="latex" /> function calls, the compiler need only specialize a class template once to know what the value is going to be, so we don&#8217;t have to worry about optimizing this implementation to make it one of linear complexity &#8212; it already is!</p>n<h2>SFINAE</h2>n<p>One of the basic rules of C++ overloading is &#8220;Substitution Failure Is Not An Error&#8221; &#8211; that is: it is not a compiler-time error for the computer to come up with a candidate for a function call, try it out and find that it won&#8217;t work because something is missing in the (substituted) type. It only <em>becomes</em> an error if there are no candidates left to try. For example, consider the following bit of code:</p>nn<div class="wp_syntax"><table><tr><td class="code"><pre class="cpp" style="font-family:monospace;"><span style="color: #339900;">#include &lt;iostream&gt;</span>n&nbsp;n<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span> std<span style="color: #008080;">;</span>n&nbsp;n<span style="color: #0000ff;">template</span> <span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">typename</span> T <span style="color: #000080;">&gt;</span>n<span style="color: #0000ff;">void</span> foo<span style="color: #008000;">&#40;</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">typename</span> T<span style="color: #008080;">::</span><span style="color: #007788;">type</span> <span style="color: #000040;">*</span><span style="color: #008000;">&#41;</span>n<span style="color: #008000;">&#123;</span>n <span style="color: #0000dd;">cout</span> <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot;first&quot;</span> <span style="color: #000080;">&lt;&lt;</span> endl<span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span>n&nbsp;n<span style="color: #0000ff;">template</span> <span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">typename</span> T <span style="color: #000080;">&gt;</span>n<span style="color: #0000ff;">void</span> foo<span style="color: #008000;">&#40;</span>...<span style="color: #008000;">&#41;</span>n<span style="color: #008000;">&#123;</span>n <span style="color: #0000dd;">cout</span> <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot;second&quot;</span> <span style="color: #000080;">&lt;&lt;</span> endl<span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span>n&nbsp;n<span style="color: #0000ff;">struct</span> Sn<span style="color: #008000;">&#123;</span>n<span style="color: #666666;">// typedef int type;</span>n<span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span>n&nbsp;n<span style="color: #0000ff;">int</span> main<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>n<span style="color: #008000;">&#123;</span>n S s<span style="color: #008080;">;</span>n foo<span style="color: #000080;">&lt;</span> S <span style="color: #000080;">&gt;</span><span style="color: #008000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span></pre></td></tr></table></div>nn<p>Which version of <code>foo</code> gets called?</p>n<p>The second.</p>n<p>The reason is that the structure <code>S</code> does not have a member type named <code>type</code> (it was commented out). The compiler will try the first version of <code>foo</code> first, substituting <code>S</code> for <code>T</code>, fail, because <code>type</code> is missing, then choose the next candidate, which will work. In this case, <code>0</code> would first be considered as a pointer to <code>S::type</code>, which is better than considering it for a parameter to a variadic function &#8212; and therefore takes precedence.</p>n<p>If you remove the comment from the typedef in <code>S</code>, so <code>S::type</code> exists, the first version will be called.</p>n<p>For this to be useful, you don&#8217;t really have to call the function. In fact, for this to be useful <em>at compile-time</em>, you <em>can&#8217;t</em> call the function. You <em>can</em>, however, take the size of the return value of the function, like this:</p>nn<div class="wp_syntax"><table><tr><td class="code"><pre class="cpp" style="font-family:monospace;"><span style="color: #339900;">#include &lt;iostream&gt;</span>n&nbsp;n<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span> std<span style="color: #008080;">;</span>n&nbsp;n<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">int</span> yes<span style="color: #008080;">;</span>n<span style="color: #0000ff;">struct</span> no <span style="color: #008000;">&#123;</span> <span style="color: #0000ff;">int</span> no<span style="color: #008000;">&#91;</span><span style="color: #0000dd;">2</span><span style="color: #008000;">&#93;</span><span style="color: #008080;">;</span> <span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span>n&nbsp;n<span style="color: #0000ff;">template</span> <span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">typename</span> T <span style="color: #000080;">&gt;</span>nyes foo<span style="color: #008000;">&#40;</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">typename</span> T<span style="color: #008080;">::</span><span style="color: #007788;">type</span> <span style="color: #000040;">*</span><span style="color: #008000;">&#41;</span>n<span style="color: #008000;">&#123;</span>n <span style="color: #0000dd;">cout</span> <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot;first&quot;</span> <span style="color: #000080;">&lt;&lt;</span> endl<span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span>n&nbsp;n<span style="color: #0000ff;">template</span> <span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">typename</span> T <span style="color: #000080;">&gt;</span>nno foo<span style="color: #008000;">&#40;</span>...<span style="color: #008000;">&#41;</span>n<span style="color: #008000;">&#123;</span>n <span style="color: #0000dd;">cout</span> <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot;second&quot;</span> <span style="color: #000080;">&lt;&lt;</span> endl<span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span>n&nbsp;n<span style="color: #0000ff;">struct</span> Sn<span style="color: #008000;">&#123;</span>n <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">int</span> type<span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span>n&nbsp;n<span style="color: #0000ff;">int</span> main<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>n<span style="color: #008000;">&#123;</span>n S s<span style="color: #008080;">;</span>n <span style="color: #0000dd;">cout</span> <span style="color: #000080;">&lt;&lt;</span> <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #008000;">&#40;</span>foo<span style="color: #000080;">&lt;</span> S <span style="color: #000080;">&gt;</span><span style="color: #008000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span> <span style="color: #000080;">==</span> <span style="color: #0000dd;">sizeof</span><span style="color: #008000;">&#40;</span>yes<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span> <span style="color: #008080;">?</span> <span style="color: #FF0000;">&quot;yes&quot;</span> <span style="color: #008080;">:</span> <span style="color: #008000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #008000;">&#40;</span>foo<span style="color: #000080;">&lt;</span> S <span style="color: #000080;">&gt;</span><span style="color: #008000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span> <span style="color: #000080;">==</span> <span style="color: #0000dd;">sizeof</span><span style="color: #008000;">&#40;</span>no<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span> <span style="color: #008080;">?</span> <span style="color: #FF0000;">&quot;no&quot;</span> <span style="color: #008080;">:</span> <span style="color: #FF0000;">&quot;dunno&quot;</span><span style="color: #008000;">&#41;</span> <span style="color: #000080;">&lt;&lt;</span> endl<span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span></pre></td></tr></table></div>nn<p>This code outputs &#8220;yes&#8221; when <code>S</code> has the <code>type</code> typedef, &#8220;no&#8221; if not &#8211; neither of the two functions get called (it doesn&#8217;t output &#8220;first&#8221; or &#8220;second&#8221; and will never output &#8220;dunno&#8221; either).</p>n<p>In fact, the bodies of the two functions don&#8217;t need to exist:</p>nn<div class="wp_syntax"><table><tr><td class="code"><pre class="cpp" style="font-family:monospace;"><span style="color: #339900;">#include &lt;iostream&gt;</span>n&nbsp;n<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span> std<span style="color: #008080;">;</span>n&nbsp;n<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">int</span> yes<span style="color: #008080;">;</span>n<span style="color: #0000ff;">struct</span> no <span style="color: #008000;">&#123;</span> <span style="color: #0000ff;">int</span> no<span style="color: #008000;">&#91;</span><span style="color: #0000dd;">2</span><span style="color: #008000;">&#93;</span><span style="color: #008080;">;</span> <span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span>n&nbsp;n<span style="color: #0000ff;">template</span> <span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">typename</span> T <span style="color: #000080;">&gt;</span>nyes foo<span style="color: #008000;">&#40;</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">typename</span> T<span style="color: #008080;">::</span><span style="color: #007788;">type</span> <span style="color: #000040;">*</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>n&nbsp;n<span style="color: #0000ff;">template</span> <span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">typename</span> T <span style="color: #000080;">&gt;</span>nno foo<span style="color: #008000;">&#40;</span>...<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>n&nbsp;n<span style="color: #0000ff;">struct</span> Sn<span style="color: #008000;">&#123;</span>n<span style="color: #666666;">// typedef int type;</span>n<span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span>n&nbsp;n<span style="color: #0000ff;">int</span> main<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>n<span style="color: #008000;">&#123;</span>n S s<span style="color: #008080;">;</span>n <span style="color: #0000dd;">cout</span> <span style="color: #000080;">&lt;&lt;</span> <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #008000;">&#40;</span>foo<span style="color: #000080;">&lt;</span> S <span style="color: #000080;">&gt;</span><span style="color: #008000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span> <span style="color: #000080;">==</span> <span style="color: #0000dd;">sizeof</span><span style="color: #008000;">&#40;</span>yes<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span> <span style="color: #008080;">?</span> <span style="color: #FF0000;">&quot;yes&quot;</span> <span style="color: #008080;">:</span> <span style="color: #008000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #008000;">&#40;</span>foo<span style="color: #000080;">&lt;</span> S <span style="color: #000080;">&gt;</span><span style="color: #008000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span> <span style="color: #000080;">==</span> <span style="color: #0000dd;">sizeof</span><span style="color: #008000;">&#40;</span>no<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span> <span style="color: #008080;">?</span> <span style="color: #FF0000;">&quot;no&quot;</span> <span style="color: #008080;">:</span> <span style="color: #FF0000;">&quot;dunno&quot;</span><span style="color: #008000;">&#41;</span> <span style="color: #000080;">&lt;&lt;</span> endl<span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span></pre></td></tr></table></div>nn<p>This version will work just as well.</p>n<p>This means we can now select on the existence of a member type of a class, which we can use to create a meta-function that will tell us just that:</p>nn<div class="wp_syntax"><table><tr><td class="code"><pre class="cpp" style="font-family:monospace;"><span style="color: #0000ff;">namespace</span> Detailsn<span style="color: #008000;">&#123;</span>n<span style="color: #0000ff;">template</span> <span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">typename</span> F <span style="color: #000080;">&gt;</span>n<span style="color: #0000ff;">struct</span> has_nextn<span style="color: #008000;">&#123;</span>n <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">char</span> yes<span style="color: #008000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #008000;">&#93;</span><span style="color: #008080;">;</span>n <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">char</span> no<span style="color: #008000;">&#91;</span><span style="color: #0000dd;">2</span><span style="color: #008000;">&#93;</span><span style="color: #008080;">;</span>n&nbsp;n <span style="color: #0000ff;">template</span> <span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">typename</span> C <span style="color: #000080;">&gt;</span>n <span style="color: #0000ff;">static</span> yes<span style="color: #000040;">&amp;</span> test<span style="color: #008000;">&#40;</span><span style="color: #0000ff;">typename</span> C<span style="color: #008080;">::</span><span style="color: #007788;">next</span> <span style="color: #000040;">*</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>n&nbsp;n <span style="color: #0000ff;">template</span> <span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">typename</span> C <span style="color: #000080;">&gt;</span>n <span style="color: #0000ff;">static</span> no<span style="color: #000040;">&amp;</span> test<span style="color: #008000;">&#40;</span>...<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>n&nbsp;n <span style="color: #0000ff;">enum</span> <span style="color: #008000;">&#123;</span> value <span style="color: #000080;">=</span> <span style="color: #0000dd;">sizeof</span><span style="color: #008000;">&#40;</span>test<span style="color: #000080;">&lt;</span>F<span style="color: #000080;">&gt;</span><span style="color: #008000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span> <span style="color: #000080;">==</span> <span style="color: #0000dd;">sizeof</span><span style="color: #008000;">&#40;</span>yes<span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span>n <span style="color: #0000ff;">typedef</span> has_next<span style="color: #000080;">&lt;</span> F <span style="color: #000080;">&gt;</span> type<span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span></pre></td></tr></table></div>nn<p>This meta-function will tell you whether a given type has a nested typedef (or type) called <code>next</code>. We&#8217;ll use this knowledge to know when to stop filling our array:</p>nn<div class="wp_syntax"><table><tr><td class="code"><pre class="cpp" style="font-family:monospace;"><span style="color: #0000ff;">template</span> <span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">typename</span> F, <span style="color: #0000ff;">bool</span> has_next__ <span style="color: #000080;">&gt;</span>n<span style="color: #0000ff;">struct</span> Filler_n<span style="color: #008000;">&#123;</span>n <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> fill<span style="color: #008000;">&#40;</span><span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">int</span> <span style="color: #000040;">*</span>a<span style="color: #008000;">&#41;</span>n <span style="color: #008000;">&#123;</span>n <span style="color: #000040;">*</span>a <span style="color: #000080;">=</span> F<span style="color: #008080;">::</span><span style="color: #007788;">value</span><span style="color: #008080;">;</span>n Filler_<span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">typename</span> F<span style="color: #008080;">::</span><span style="color: #007788;">next</span>, has_next<span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">typename</span> F<span style="color: #008080;">::</span><span style="color: #007788;">next</span> <span style="color: #000080;">&gt;</span><span style="color: #008080;">::</span><span style="color: #007788;">value</span> <span style="color: #000080;">&gt;</span><span style="color: #008080;">::</span><span style="color: #007788;">fill</span><span style="color: #008000;">&#40;</span><span style="color: #000040;">++</span>a<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>n <span style="color: #008000;">&#125;</span>n<span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span>n&nbsp;n<span style="color: #0000ff;">template</span> <span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">typename</span> F <span style="color: #000080;">&gt;</span>n<span style="color: #0000ff;">struct</span> Filler_<span style="color: #000080;">&lt;</span> F, <span style="color: #0000ff;">false</span> <span style="color: #000080;">&gt;</span>n<span style="color: #008000;">&#123;</span>n <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> fill<span style="color: #008000;">&#40;</span><span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">int</span> <span style="color: #000040;">*</span>a<span style="color: #008000;">&#41;</span>n <span style="color: #008000;">&#123;</span>n <span style="color: #000040;">*</span>a <span style="color: #000080;">=</span> F<span style="color: #008080;">::</span><span style="color: #007788;">value</span><span style="color: #008080;">;</span>n <span style="color: #008000;">&#125;</span>n<span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span>n&nbsp;n<span style="color: #0000ff;">template</span> <span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">typename</span> F <span style="color: #000080;">&gt;</span>n<span style="color: #0000ff;">void</span> fill<span style="color: #008000;">&#40;</span><span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">int</span> <span style="color: #000040;">*</span>a<span style="color: #008000;">&#41;</span>n<span style="color: #008000;">&#123;</span>n Filler_<span style="color: #000080;">&lt;</span> F, has_next<span style="color: #000080;">&lt;</span> F <span style="color: #000080;">&gt;</span><span style="color: #008080;">::</span><span style="color: #007788;">value</span> <span style="color: #000080;">&gt;</span><span style="color: #008080;">::</span><span style="color: #007788;">fill</span><span style="color: #008000;">&#40;</span>a<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span></pre></td></tr></table></div>nn<p>As you can see, <code>Filler_::fill</code> calls itself recursively until the corresponding instance of <code>Fibonacci_</code> no longer has a <code>next</code> nested type. So, now <code>fill</code> can look like this:</p>nn<div class="wp_syntax"><table><tr><td class="code"><pre class="cpp" style="font-family:monospace;"><span style="color: #0000ff;">template</span> <span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">typename</span> F <span style="color: #000080;">&gt;</span>n<span style="color: #0000ff;">void</span> fill<span style="color: #008000;">&#40;</span><span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">int</span> <span style="color: #000040;">*</span>a<span style="color: #008000;">&#41;</span>n<span style="color: #008000;">&#123;</span>n Filler_<span style="color: #000080;">&lt;</span> F, has_next<span style="color: #000080;">&lt;</span> F <span style="color: #000080;">&gt;</span><span style="color: #008080;">::</span><span style="color: #007788;">value</span> <span style="color: #000080;">&gt;</span><span style="color: #008080;">::</span><span style="color: #007788;">fill</span><span style="color: #008000;">&#40;</span>a<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span></pre></td></tr></table></div>nn<p>which will fill the array with the Fibonacci sequence.</p>n<p>You can play with this code in the on-line IDE at <a href="http://ideone.com/Thq96" >ideone.com</a></p>nn"
post_title: "Functional Programming at Compile-Time"
post_excerpt: "In the previous installment I talked about functional programming a bit, introducing the idea of functors and lambda expressions. This time, we will look at another type of functional programming: a type that is done at compile-time. Meta-functions In functional &hellip; <a href="http://rlc.vlinder.ca/blog/2011/06/functional-programming-at-compile-time-cpp4theselftaught/">Continue reading <span>&rarr;</span></a>n"
post_status: "inherit"
comment_status: "open"
ping_status: "open"
post_password: ""
post_name: "40-revision-v1"
to_ping: ""
pinged: ""
post_modified: "2014-01-12 21:34:10"
post_modified_gmt: "2014-01-13 02:34:10"
post_content_filtered: ""
post_parent: 40
guid: "http://cpp4theselftaught.com/2014/01/40-revision-v1/"
menu_order: 0
post_type: "revision"
post_mime_type: ""
comment_count: 0
