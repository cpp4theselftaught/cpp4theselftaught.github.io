ID: 53
post_author: 1
post_date: "2011-05-19 21:47:12"
post_date_gmt: "2011-05-20 02:47:12"
post_content: "n<div class="topsy_widget_data topsy_theme_blue" style="float: right;margin-left: 0.75em; background: url(data:,%7B%20%22url%22%3A%20%22http%253A%252F%252Frlc.vlinder.ca%252Fblog%252F2011%252F05%252Fusing-ranges-and-functional-programming-in-c-cpp4theselftaught%252F%22%2C%20%22shorturl%22%3A%20%22http%3A%2F%2Fbit.ly%2FiWEQMe%22%2C%20%22style%22%3A%20%22big%22%2C%20%22title%22%3A%20%22Using%20Ranges%20and%20Functional%20Programming%20in%20C%2B%2B%22%20%7D);"></div>n<p> <audio id="wp_mep_6" controls="controls" src="http://vlinder.ca/podcasts/30-functional.mp3" preload="none" class="mejs-player " data-mejsoptions='{"features":["playpause","current","progress","duration","volume","tracks","fullscreen"],"audioWidth":400,"audioHeight":30}'>n n <object width="400" height="30" type="application/x-shockwave-flash" data="http://rlc.vlinder.ca/wp-content/plugins/media-element-html5-video-and-audio-player/mediaelement/flashmediaelement.swf">n <param name="movie" value="http://rlc.vlinder.ca/wp-content/plugins/media-element-html5-video-and-audio-player/mediaelement/flashmediaelement.swf" />n <param name="flashvars" value="controls=true&amp;file=http://vlinder.ca/podcasts/30-functional.mp3" /> n </object> n </audio>C++ is a very versatile language. Among other things, you can do generic meta-programming and functional programming in C++, as well as the better-known facilities for procedural and object-oriented programming. In this installment, we will look at the functional programming facilities in the now-current C++ standard (C++03) as well as the upcoming C++0x standard. We will look at what a <em>closure</em> is and how to apply one to a range, but we will first look at some simpler uses of ranges &#8212; to warm up.<br />n<span id="more-1399"></span><br />nIf you look at the current version of Chausette, in the code for episode 28, you will find this:</p>nn<div class="wp_syntax"><table><tr><td class="line_numbers"><pre>1n2n3n4n5n6n7n8n9n10n11n12n13n14n</pre></td><td class="code"><pre class="cpp" style="font-family:monospace;"><span style="color: #0000ff;">int</span> main<span style="color: #008000;">&#40;</span><span style="color: #0000ff;">int</span> argc, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> <span style="color: #000040;">**</span>argv<span style="color: #008000;">&#41;</span>n<span style="color: #008000;">&#123;</span>n Application<span style="color: #008080;">::</span><span style="color: #007788;">Arguments</span> arguments<span style="color: #008000;">&#40;</span>argc<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>n std<span style="color: #008080;">::</span><span style="color: #007788;">copy</span><span style="color: #008000;">&#40;</span>argv, argv <span style="color: #000040;">+</span> argc, arguments.<span style="color: #007788;">begin</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>n Application application<span style="color: #008080;">;</span>n <span style="color: #0000ff;">try</span>n <span style="color: #008000;">&#123;</span>n application.<span style="color: #007788;">run</span><span style="color: #008000;">&#40;</span>arguments<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>n <span style="color: #008000;">&#125;</span>n <span style="color: #0000ff;">catch</span> <span style="color: #008000;">&#40;</span>...<span style="color: #008000;">&#41;</span>n <span style="color: #008000;">&#123;</span>n std<span style="color: #008080;">::</span><span style="color: #0000dd;">cerr</span> <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot;An error occurred&quot;</span> <span style="color: #000080;">&lt;&lt;</span> std<span style="color: #008080;">::</span><span style="color: #007788;">endl</span><span style="color: #008080;">;</span>n <span style="color: #008000;">&#125;</span>n<span style="color: #008000;">&#125;</span></pre></td></tr></table></div>nn<p>On line 4 of this listing, you can see our first use of a range: using <code>copy</code>, we copy the range of arguments passed to the application into the <code>arguments</code> vector.<sup><a href="http://rlc.vlinder.ca/blog/2011/05/using-ranges-and-functional-programming-in-c-cpp4theselftaught/#footnote_0_1399" id="identifier_0_1399" class="footnote-link footnote-identifier-link" title="Note that this is not functional programming (yet), but in order to understand how functional programming is thought of in (current) C++, it is important to understand how ranges work.">1</a></sup> The range that contains all the arguments is <code>argc</code> in size (which is why the vector is initialized to contain <code>argc</code> elements) and starts at <code>argv</code>. This same approach to ranges works for all C-style arrays: the <code>begin</code>ning of the range points at the first element, the <code>end</code> of the range points one past the last element. We note a range like this: <code>[begin, end)</code>. Using <code>begin</code> and <code>end</code> in this manner works for STL containers as well, and is the basic premise for all STL algorithms.</p>n<p>If you look at the code for <code>std::copy</code> you'll find something like this<sup><a href="http://rlc.vlinder.ca/blog/2011/05/using-ranges-and-functional-programming-in-c-cpp4theselftaught/#footnote_1_1399" id="identifier_1_1399" class="footnote-link footnote-identifier-link" title="The real code will likely be more complicated because of some optimizations the implementation may do, but the general idea is the same.">2</a></sup>:</p>nn<div class="wp_syntax"><table><tr><td class="code"><pre class="cpp" style="font-family:monospace;"><span style="color: #0000ff;">template</span> <span style="color: #000080;">&lt;</span> <span style="color: #0000ff;">typename</span> InIter, <span style="color: #0000ff;">typename</span> OutIter <span style="color: #000080;">&gt;</span>nOutIter copy<span style="color: #008000;">&#40;</span>InIter begin, InIter end, OutIter result<span style="color: #008000;">&#41;</span>n<span style="color: #008000;">&#123;</span>n <span style="color: #0000ff;">for</span> <span style="color: #008000;">&#40;</span><span style="color: #008080;">;</span> begin <span style="color: #000040;">!</span><span style="color: #000080;">=</span> end<span style="color: #008080;">;</span> <span style="color: #000040;">++</span>begin<span style="color: #008000;">&#41;</span>n <span style="color: #008000;">&#123;</span>n <span style="color: #000040;">*</span>result<span style="color: #000040;">++</span> <span style="color: #000080;">=</span> <span style="color: #000040;">*</span>begin<span style="color: #008080;">;</span>n <span style="color: #008000;">&#125;</span>n <span style="color: #0000ff;">return</span> result<span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span></pre></td></tr></table></div>nn<p>So why not implement the loop directly?</p>n<p>There are many reasons not to implement the loop directly in the code. One is the age-old reason of code re-use. It is for that reason that we practice object-oriented programming, that we have libraries of code and that we have functions. We re-use code because that means we don't have to write as much code (laziness is a virtue in this case) and because we only have to debug the code once. If the code is well-written, having debugged it once means we don't even have to look at it ever again.</p>n<p>For those same reasons, C++ has generic template meta-programming, allowing <code>copy</code> to be used for any sort of range containing elements of any type - as long as they are <strong>Assignable</strong>. In this case, we've used it to implement copying a range of C-style strings into a vector of C++-style strings but the same code can copy arrays of integers, the contents of STL containers, etc. Note, by the way, that the copy we did here involves an implicit conversion of the C-style string to the C++-style string: we didn't have to provide any extra code for that because the <code>std::string</code> constructor allows for implicit conversion of <code>const char *</code>.</p>n<p>Let's go a bit further in the code and see what happens in <code>Server::update</code>:</p>nn<div class="wp_syntax"><table><tr><td class="line_numbers"><pre>41n42n43n44n45n46n47n48n49n50n51n52n53n54n55n56n57n58n59n60n61n62n63n64n</pre></td><td class="code"><pre class="cpp" style="font-family:monospace;"><span style="color: #0000ff;">struct</span> Functorn<span style="color: #008000;">&#123;</span>n Functor<span style="color: #008000;">&#40;</span>fd_set <span style="color: #000040;">&amp;</span>an_fd_set, <span style="color: #0000ff;">bool</span> Socket<span style="color: #008080;">::</span><span style="color: #000040;">*</span> member, <span style="color: #0000ff;">int</span> <span style="color: #000040;">&amp;</span>highest_fd<span style="color: #008000;">&#41;</span>n <span style="color: #008080;">:</span> fd_set_<span style="color: #008000;">&#40;</span>an_fd_set<span style="color: #008000;">&#41;</span>n , member_<span style="color: #008000;">&#40;</span>member<span style="color: #008000;">&#41;</span>n , highest_fd_<span style="color: #008000;">&#40;</span>highest_fd<span style="color: #008000;">&#41;</span>n <span style="color: #008000;">&#123;</span> <span style="color: #ff0000; font-style: italic;">/* no-op */</span> <span style="color: #008000;">&#125;</span>n&nbsp;n Functor <span style="color: #000040;">&amp;</span>operator<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#40;</span><span style="color: #0000ff;">const</span> Socket <span style="color: #000040;">&amp;</span>socket<span style="color: #008000;">&#41;</span>n <span style="color: #008000;">&#123;</span>n <span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span><span style="color: #000040;">!</span><span style="color: #008000;">&#40;</span>socket.<span style="color: #000040;">*</span>member_<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span>n <span style="color: #008000;">&#123;</span>n FD_SET<span style="color: #008000;">&#40;</span>socket.<span style="color: #007788;">fd_</span>, <span style="color: #000040;">&amp;</span>fd_set_<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>n <span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>highest_fd_ <span style="color: #000080;">&lt;</span> socket.<span style="color: #007788;">fd_</span><span style="color: #008000;">&#41;</span> highest_fd_ <span style="color: #000080;">=</span> socket.<span style="color: #007788;">fd_</span><span style="color: #008080;">;</span>n <span style="color: #008000;">&#125;</span>n <span style="color: #0000ff;">else</span>n <span style="color: #008000;">&#123;</span> <span style="color: #ff0000; font-style: italic;">/* don't want this one */</span> <span style="color: #008000;">&#125;</span>n <span style="color: #0000ff;">return</span> <span style="color: #000040;">*</span><span style="color: #0000dd;">this</span><span style="color: #008080;">;</span>n <span style="color: #008000;">&#125;</span>n&nbsp;n fd_set <span style="color: #000040;">&amp;</span>fd_set_<span style="color: #008080;">;</span>n <span style="color: #0000ff;">bool</span> Socket<span style="color: #008080;">::</span><span style="color: #000040;">*</span> member_<span style="color: #008080;">;</span>n <span style="color: #0000ff;">int</span> <span style="color: #000040;">&amp;</span>highest_fd_<span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span></pre></td></tr></table></div>nnn<div class="wp_syntax"><table><tr><td class="line_numbers"><pre>133n134n135n136n137n</pre></td><td class="code"><pre class="cpp" style="font-family:monospace;">fd_set read_fds<span style="color: #008080;">;</span>nFD_ZERO<span style="color: #008000;">&#40;</span><span style="color: #000040;">&amp;</span>read_fds<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>nstd<span style="color: #008080;">::</span><span style="color: #007788;">for_each</span><span style="color: #008000;">&#40;</span>n sockets_.<span style="color: #007788;">begin</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>, sockets_.<span style="color: #007788;">end</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>,n Functor<span style="color: #008000;">&#40;</span>read_fds, <span style="color: #000040;">&amp;</span>Socket<span style="color: #008080;">::</span><span style="color: #007788;">read_avail_</span>, highest_fd<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span></pre></td></tr></table></div>nn<p>In lines 41 through 64, we define the class <code>Functor</code>. This class models a function object (a.k.a. a functor) which, once constructed, behaves exactly like a function would, thanks to the overloaded <code>operator()</code> -- the function-call operator.<sup><a href="http://rlc.vlinder.ca/blog/2011/05/using-ranges-and-functional-programming-in-c-cpp4theselftaught/#footnote_2_1399" id="identifier_2_1399" class="footnote-link footnote-identifier-link" title="Of course, I would not ordinarily call this functor Functor, but I had a point to make. Do not, however, call all your functors by the kind of thing they are -- name them according to their functionality, as you would (should) any other chunk of code.">3</a></sup> In line 137<sup><a href="http://rlc.vlinder.ca/blog/2011/05/using-ranges-and-functional-programming-in-c-cpp4theselftaught/#footnote_3_1399" id="identifier_3_1399" class="footnote-link footnote-identifier-link" title="135 in the actual code in Git">4</a></sup>, the function-object is constructed and is subsequently called for each object in the <code>sockets_</code> list, meaning that for each of those objects, the function-call operator of the <code>Functor</code> class is called.</p>n<p>This is functional programming, as allowed by C++03 -- the current standard for C++.</p>n<p>Note that there's a wee bit of magic here: in order to allow us to use the same functor for each <code>fd_set</code> we mean to set up, we pass a <em>pointer to a boolean member</em> of the <code>Socket</code> structure that will be checked in the function-call operator. That is what <code>bool Socket::* member_</code> means: <code>member_</code> is a pointer to a member of <code>Socket</code> that has <code>bool</code> type. In C++0x, we won't need to go to so much trouble: we will be able to use <em>lambda expressions</em>.</p>n<p>Lambda expressions are a concise way to create a functor class by just defining three things:</p>n<ol>n<li>what is <em>captured</em> from the definition's environment (in our case, that would be the <code>fd_set</code> to work on and the currently-highest file descriptor)</li>n<li>the parameters of the function (just like any other function); and</li>n<li>the body of the function.</li>n</ol>n<p>These three, together, produce a <em>closure</em> which, if you're not used to it, looks a bit strange. Here's a simple example:</p>nn<div class="wp_syntax"><table><tr><td class="line_numbers"><pre>1n2n3n4n5n6n7n8n9n10n</pre></td><td class="code"><pre class="cpp" style="font-family:monospace;"><span style="color: #339900;">#include &lt;algorithm&gt;</span>n<span style="color: #339900;">#include &lt;iostream&gt;</span>n&nbsp;n<span style="color: #0000ff;">int</span> main<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>n<span style="color: #008000;">&#123;</span>n <span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span> std<span style="color: #008080;">;</span>n <span style="color: #0000ff;">int</span> a<span style="color: #008000;">&#91;</span><span style="color: #0000dd;">5</span><span style="color: #008000;">&#93;</span> <span style="color: #000080;">=</span> <span style="color: #008000;">&#123;</span><span style="color: #0000dd;">1</span>, <span style="color: #0000dd;">2</span>, <span style="color: #0000dd;">3</span>, <span style="color: #0000dd;">4</span>, <span style="color: #0000dd;">5</span><span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span>n&nbsp;n for_each<span style="color: #008000;">&#40;</span>a, a <span style="color: #000040;">+</span> <span style="color: #0000dd;">5</span>, <span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span><span style="color: #008000;">&#40;</span><span style="color: #0000ff;">int</span> i<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#123;</span> <span style="color: #0000dd;">cout</span> <span style="color: #000080;">&lt;&lt;</span> i <span style="color: #000080;">&lt;&lt;</span> endl<span style="color: #008080;">;</span> <span style="color: #008000;">&#125;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span></pre></td></tr></table></div>nn<p>In this case, the lambda expression is <code>[](int i){ cout << i << endl; }</code>: it doesn't capture anything (<code>[]</code> is an empty capture set<sup><a href="http://rlc.vlinder.ca/blog/2011/05/using-ranges-and-functional-programming-in-c-cpp4theselftaught/#footnote_4_1399" id="identifier_4_1399" class="footnote-link footnote-identifier-link" title="I should note that the term &quot;capture set&quot; is not mentioned anywhere in the draft standard. I take it to mean the set of actually captured variables, which is the result of the lambda-capture being applied">5</a></sup>), takes an integer <code>i</code> as parameter and outputs that integer to <code>cout</code>.</p>n<p>Now, the lambda expression in this code doesn't actually capture anything. To show how that works, let's capture the array that we loop over:</p>nn<div class="wp_syntax"><table><tr><td class="line_numbers"><pre>1n2n3n4n5n6n7n8n9n10n11n12n13n14n15n16n</pre></td><td class="code"><pre class="cpp" style="font-family:monospace;"><span style="color: #339900;">#include &lt;algorithm&gt;</span>n<span style="color: #339900;">#include &lt;iostream&gt;</span>n&nbsp;n<span style="color: #0000ff;">int</span> main<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>n<span style="color: #008000;">&#123;</span>n <span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span> std<span style="color: #008080;">;</span>n <span style="color: #0000ff;">int</span> a<span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span> <span style="color: #000080;">=</span> <span style="color: #008000;">&#123;</span><span style="color: #0000dd;">1</span>, <span style="color: #0000dd;">2</span>, <span style="color: #0000dd;">3</span>, <span style="color: #0000dd;">4</span>, <span style="color: #0000dd;">5</span><span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span>n&nbsp;n <span style="color: #0000ff;">auto</span> <span style="color: #0000ff;">const</span> f <span style="color: #000080;">=</span> <span style="color: #008000;">&#91;</span><span style="color: #000080;">=</span><span style="color: #008000;">&#93;</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#123;</span>n for_each<span style="color: #008000;">&#40;</span>a, a <span style="color: #000040;">+</span> <span style="color: #008000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #008000;">&#40;</span>a<span style="color: #008000;">&#41;</span> <span style="color: #000040;">/</span> <span style="color: #0000dd;">sizeof</span><span style="color: #008000;">&#40;</span>a<span style="color: #008000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #008000;">&#93;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span>, <span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span><span style="color: #008000;">&#40;</span><span style="color: #0000ff;">int</span> i<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#123;</span> <span style="color: #0000dd;">cout</span> <span style="color: #000080;">&lt;&lt;</span> i <span style="color: #000080;">&lt;&lt;</span> endl<span style="color: #008080;">;</span> <span style="color: #008000;">&#125;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>n <span style="color: #008000;">&#125;</span><span style="color: #008080;">;</span>n&nbsp;n a<span style="color: #008000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #008000;">&#93;</span> <span style="color: #000080;">=</span> <span style="color: #0000dd;">2</span><span style="color: #008080;">;</span>n&nbsp;n f<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>n<span style="color: #008000;">&#125;</span></pre></td></tr></table></div>nn<p>This lambda expression captures the array <code>a</code> by value, so changing the value of one of the integers in the array on line 13 doesn't actually have any effect on the output produced by calling the function on line 15. If we had captured the array by reference, the output would have been different.</p>n<p>There are three versions of this example that you can play with at ideone.com:</p>n<ol>n<li><a href="http://ideone.com/v5J6f" >the example</a> code itself</code></li>n<li><a href="http://ideone.com/v8Wsr" >a modified version of the example code</a>, in which there is another enclosed lamda expression</li>n<li><a href="http://ideone.com/cMwCa" >another modified version of the example code</a>, in which the enclosed lambda expression is returned immediatele</li>n</ol>n<p>If you have any questions about what you find when you play with that code, feel free to ask.</p>n<p>Lambda expressions are new features of the C++ programming language, but the functional style of programming has existed in C++ since the beginning: if it is possible to call an object as a function, it is possible to use a functional style of programming. Lambda expressions just make it a bit more interesting. The compilers we&#8217;ll want to support for Chausette, however, don&#8217;t have most of the features of C++0x (as most compilers don&#8217;t) but now that the final draft is out, we&#8217;ll add a few notes on C++0x in the installments, when it makes sense to do so.</p>n<p>Once you get a good handle on functional programming, generic template meta-programming becomes a lot easier as it is mostly functional programming, but the program runs at compile-time. We will discuss meta-programming in future installments.</p>nn<ol class="footnotes"><li id="footnote_0_1399" class="footnote">Note that this is not functional programming (yet), but in order to understand how functional programming is thought of in (current) C++, it is important to understand how ranges work.</li><li id="footnote_1_1399" class="footnote">The real code will likely be more complicated because of some optimizations the implementation may do, but the general idea is the same.</li><li id="footnote_2_1399" class="footnote">Of course, I would not ordinarily call this functor <code>Functor</code>, but I had a point to make. Do not, however, call all your functors by the kind of thing they are -- name them according to their functionality, as you would (should) any other chunk of code.</li><li id="footnote_3_1399" class="footnote">135 in the actual code in Git</li><li id="footnote_4_1399" class="footnote">I should note that the term "capture set" is not mentioned anywhere in the draft standard. I take it to mean the set of actually captured variables, which is the result of the <i>lambda-capture</i> being applied</li></ol>"
post_title: "Using Ranges and Functional Programming in C++"
post_excerpt: "C++ is a very versatile language. Among other things, you can do generic meta-programming and functional programming in C++, as well as the better-known facilities for procedural and object-oriented programming. In this installment, we will look at the functional programming &#8230; <a href="http://rlc.vlinder.ca/blog/2011/05/using-ranges-and-functional-programming-in-c-cpp4theselftaught/">Continue reading <span>&#8594;</span></a>"
post_status: "inherit"
comment_status: "open"
ping_status: "open"
post_password: ""
post_name: "41-revision"
to_ping: ""
pinged: ""
post_modified: "2011-05-19 21:47:12"
post_modified_gmt: "2011-05-20 02:47:12"
post_content_filtered: ""
post_parent: 41
guid: "http://cpp4theselftaught.com/2011/05/41-revision/"
menu_order: 0
post_type: "revision"
post_mime_type: ""
comment_count: 0
