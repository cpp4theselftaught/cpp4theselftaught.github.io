ID: 151
post_author: 1
post_date: "2012-12-04 22:21:06"
post_date_gmt: "2012-12-05 02:21:06"
post_content: "n<div class="topsy_widget_data topsy_theme_blue" style="float: right;margin-left: 0.75em; background: url(data:,%7B%20%22url%22%3A%20%22http%253A%252F%252Frlc.vlinder.ca%252Fblog%252F2012%252F12%252Fhow-to-design-a-struct-for-storage-or-networking%252F%22%2C%20%22shorturl%22%3A%20%22http%3A%2F%2Fbit.ly%2F11QNfI8%22%2C%20%22style%22%3A%20%22big%22%2C%20%22title%22%3A%20%22How%20to%20design%20a%20struct%20for%20storage%20or%20communicating%20%23communicating%20%23design%20%23storage%20%23struct%22%20%7D);"></div>n<p>One of the most common ways of &#8220;persisting&#8221; or communicating data in an embedded device is to just dump it into persistent storage or onto the wire: rather than generating XML, JSON or some other format which would later have to be parsed and which takes a lot of resources both ways, both in terms of CPU time to generate and parse and in terms of storage overhead, dumping binary data into storage or onto the wire has only the &#8212; inevitable &#8212; overhead of accessing storage/the wire itself. There are, however, several caveats to this, some of which I run into on a more-or-less regular basis when trying to decipher some of that data, so in stead of just being frustrated with hard-to-decipher data, I choose to describe how it should be done in stead.</p>n<p>Note that I am by no means advocating anything more than a few simple rules to follow when dumping data. Particularly, I am <em>not</em> going to advocate using XML, JSON or any other intermediary form: each of those has their place, but they neither should be considered to solve the problems faced when trying to access binary data, nor can they replace binary data.</p>n<p><span id="more-1966"></span></p>n<h2>Necessary parts</h2>n<p>There are two things that any structure that is communicated<sup><a href="http://rlc.vlinder.ca/blog/2012/12/how-to-design-a-struct-for-storage-or-networking/#footnote_0_1966" id="identifier_0_1966" class="footnote-link footnote-identifier-link" title="and I include writing to persistent storage and reading it back later in &ldquo;communication&rdquo; because that&rsquo;s what it is: the software reading the data may very well be different from the software writing it &mdash; be it different versions of the same software, or different software altogether">1</a></sup> in binary form should have:</p>n<ol>n<li>a <strong>magic number</strong>, preferably one that is at exactly four bytes in length and one that is chosen to be human-readable, either when displayed as HEX or when displayed as &#8220;deciphered&#8221; ASCII<br />Good examples are <code>0xdeadbeef</code>; <code>0x<em>N</em>badf00d</code> in which <em>N</em> is replaced by a hexadecimal value that might mean something &#8212; you have 16 options, and you can put the N at the end, so you really now have 32 options!!; <code>'CODE'</code> (or <code>0x434f4445</code> in this case) in which CODE is replaced by something descriptive for the structure&#8217;s content. For example, if it contains a config for a potato peeler, <code>'PCFG'</code> (or <code>0x50434647</code>) would do just fine. The idea is to have some magic number that&#8217;s easy to recognize when displayed by a memory debugger or when dumped by a run-of-the-mill binary editor/viewer.</li>n<li>the <strong>version</strong> of the structure. This can be a simple incremental counter &#8212; it can even be part of the magic number of you don&#8217;t want to &#8220;waste&#8221; bytes, but it really should be in there. Ideally, it should consist of at least two parts: &#8220;current&#8221; and &#8220;age&#8221;, the idea being that you increment both &#8220;current&#8221; and &#8220;age&#8221; if you add something, and that you increment &#8220;current&#8221; and set &#8220;age&#8221; to 0 if you remove something or change the meaning of some part in a way no longer compatible with previous versions. That way, any-one who reads the structure can very easily see if they can <em>understand</em> the structure:nn<div class="wp_syntax"><table><tr><td class="code"><pre class="c" style="font-family:monospace;"><span style="color: #b1b100;">if</span> <span style="color: #009900;">&#40;</span>data.<span style="color: #202020;">magic_</span> <span style="color: #339933;">==</span> POTATO_PEELER_CONFIG_MAGIC<span style="color: #009900;">&#41;</span>n<span style="color: #009900;">&#123;</span>n <span style="color: #b1b100;">if</span> <span style="color: #009900;">&#40;</span><span style="color: #009900;">&#40;</span>data.<span style="color: #202020;">version_</span>.<span style="color: #202020;">current_</span> <span style="color: #339933;">-</span> data.<span style="color: #202020;">version_</span>.<span style="color: #202020;">age_</span><span style="color: #009900;">&#41;</span> <span style="color: #339933;">==</span> <span style="color: #009900;">&#40;</span>POTATO_PEELER_CONFIG_CURRENT <span style="color: #339933;">-</span> POTATO_PEELER_CONFIG_AGE<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span>n <span style="color: #009900;">&#123;</span>n <span style="color: #b1b100;">if</span> <span style="color: #009900;">&#40;</span>data.<span style="color: #202020;">version_</span>.<span style="color: #202020;">current_</span> <span style="color: #339933;">&gt;=</span> POTATO_PEELER_CONFIG_CURRENT<span style="color: #009900;">&#41;</span>n <span style="color: #009900;">&#123;</span>n <span style="color: #666666; font-style: italic;">// current or newer version - read it as if</span>n <span style="color: #666666; font-style: italic;">// it's current.</span>n <span style="color: #666666; font-style: italic;">// We should be able to ignore anything</span>n <span style="color: #666666; font-style: italic;">// added since (because the implementor</span>n <span style="color: #666666; font-style: italic;">// declared us to be forward-compatible,</span>n <span style="color: #666666; font-style: italic;">// after all)</span>n <span style="color: #009900;">&#125;</span>n <span style="color: #b1b100;">else</span>n <span style="color: #009900;">&#123;</span>n <span style="color: #666666; font-style: italic;">// older version. Assume default values for</span>n <span style="color: #666666; font-style: italic;">// newer fields, or follow some kind of logic</span>n <span style="color: #666666; font-style: italic;">// to keep compatibility -- after all, the</span>n <span style="color: #666666; font-style: italic;">// implementor did declare us to be</span>n <span style="color: #666666; font-style: italic;">// backward-compatible</span>n <span style="color: #009900;">&#125;</span>n <span style="color: #009900;">&#125;</span>n <span style="color: #b1b100;">else</span>n <span style="color: #009900;">&#123;</span> <span style="color: #808080; font-style: italic;">/* incompatible version - maybe fall back on conversion code..? */</span> <span style="color: #009900;">&#125;</span>n<span style="color: #009900;">&#125;</span>n<span style="color: #b1b100;">else</span>n<span style="color: #009900;">&#123;</span> <span style="color: #808080; font-style: italic;">/* not something we understand - wrong magic number */</span> <span style="color: #009900;">&#125;</span></pre></td></tr></table></div>nn</li>n</ol>n<p>With just these two in place on every persisted structure, I would have saved hours of futile staring at memory dumps and binary dumps of files from legacy (and current) systems that I was asked to debug. Basically, every persisted structure should begin like this:</p>nn<div class="wp_syntax"><table><tr><td class="code"><pre class="c" style="font-family:monospace;"><span style="color: #993333;">struct</span> PotatoPeelerConfiguration_structn<span style="color: #009900;">&#123;</span>n <span style="color: #993333;">uint32_t</span> magic_<span style="color: #339933;">;</span>n <span style="color: #993333;">uint32_t</span> version_<span style="color: #339933;">;</span></pre></td></tr></table></div>nn<p> or, if we want the code above to compile<sup><a href="http://rlc.vlinder.ca/blog/2012/12/how-to-design-a-struct-for-storage-or-networking/#footnote_1_1966" id="identifier_1_1966" class="footnote-link footnote-identifier-link" title="There is some religious debate over whether or not to do typedef struct Version_struct Version; in C headers, so I left that out, though I usually would have included it for convenience.">2</a></sup>:</p>nn<div class="wp_syntax"><table><tr><td class="code"><pre class="c" style="font-family:monospace;"><span style="color: #993333;">struct</span> Version_structn<span style="color: #009900;">&#123;</span>n <span style="color: #993333;">uint16_t</span> current_<span style="color: #339933;">;</span>n <span style="color: #993333;">uint16_t</span> age_<span style="color: #339933;">;</span>n<span style="color: #009900;">&#125;</span><span style="color: #339933;">;</span>n<span style="color: #993333;">struct</span> PotatoPeelerConfiguration_structn<span style="color: #009900;">&#123;</span>n <span style="color: #993333;">uint32_t</span> magic_<span style="color: #339933;">;</span>n <span style="color: #993333;">struct</span> Version_struct version_<span style="color: #339933;">;</span></pre></td></tr></table></div>nn<h2>The structure&#8217;s structure</h2>n<p>What&#8217;s wrong with this picture:</p>nn<div class="wp_syntax"><table><tr><td class="code"><pre class="c" style="font-family:monospace;"><span style="color: #993333;">struct</span> Blahn<span style="color: #009900;">&#123;</span>n <span style="color: #993333;">uint32_t</span> ulThingy<span style="color: #339933;">;</span>n <span style="color: #993333;">uint8_t</span> ucThingy<span style="color: #339933;">;</span>n <span style="color: #993333;">uint16_t</span> usThingy<span style="color: #339933;">;</span>n<span style="color: #009900;">&#125;</span><span style="color: #339933;">;</span></pre></td></tr></table></div>nn<p>Hint: it&#8217;s not the Hungarian notation!</p>n<p>There&#8217;s an invisible hole in this structure<sup><a href="http://rlc.vlinder.ca/blog/2012/12/how-to-design-a-struct-for-storage-or-networking/#footnote_2_1966" id="identifier_2_1966" class="footnote-link footnote-identifier-link" title="At least, there is on the vast majority of platforms">3</a></sup>. Between <code>ucThingy</code> and <code>usThingy</code> there is a one-byte hole due to the structure&#8217;s members&#8217; alignment.</p>n<p>The vast majority of compilers will insert a hole into the structure to make sure the <code>usThingy</code> member is aligned on a &#8220;natural&#8221; two-byte boundary. <em>That is the right thing to do</em>, because many hardware platforms will be <em>very</em> picky on mis-aligned data. ARM, for example, will throw a &#8216;data abort&#8217; at you whereas x86 will simply slow down to a crawl.</p>n<p><strong>Please don&#8217;t make the mistake of using <code>#pragma pack</code> for this</strong>: use <code>#pragma pack</code> only if you <em>know</em> it has no effect, and then only if you have a whole bunch of <code>assert</code>ions in your unit tests, which are run every night, checking that the <code>#pragma pack</code> has no effect on any of the platforms you target<sup><a href="http://rlc.vlinder.ca/blog/2012/12/how-to-design-a-struct-for-storage-or-networking/#footnote_3_1966" id="identifier_3_1966" class="footnote-link footnote-identifier-link" title="In other words: just don&rsquo;t use it &mdash; it&rsquo;s useless.">4</a></sup>. Using <code>#pragma pack</code> otherwise can cause mis-alignment of the contents of the structure which on some platforms (like ARM) can cause crashes.</p>n<p><em>Do</em> use filler variables to fill the holes, like this:</p>nn<div class="wp_syntax"><table><tr><td class="code"><pre class="c" style="font-family:monospace;"><span style="color: #993333;">struct</span> Blahn<span style="color: #009900;">&#123;</span>n <span style="color: #993333;">uint32_t</span> magic<span style="color: #339933;">;</span>n <span style="color: #993333;">uint32_t</span> version<span style="color: #339933;">;</span>n <span style="color: #993333;">uint32_t</span> ulThingy<span style="color: #339933;">;</span>n <span style="color: #993333;">uint8_t</span> ucThingy<span style="color: #339933;">;</span>n <span style="color: #993333;">uint8_t</span> reserved<span style="color: #339933;">;</span>n <span style="color: #993333;">uint16_t</span> usThingy<span style="color: #339933;">;</span>n<span style="color: #009900;">&#125;</span><span style="color: #339933;">;</span></pre></td></tr></table></div>nn<p>Note the magic number and version as well, which should <em>of course</em> be at the start of the structure.</p>n<p>If you&#8217;re saving a whole bunch of data to a file, or sending it over a wire, please structure it so we can skip the parts we don&#8217;t care about &#8211; e.g. by including a header with a <code>size</code> field for a section of data objects that we might want to skip over. Every object in the section should still have its own magic number and version, of course, but at least we&#8217;ll know that the next 148 bytes are configuration for orange peelers (we&#8217;re interested in potato peelers, so we&#8217;ll skip those 148 bytes, thank you very much).</p>n<p>If you add something to a structure, <em>unless you have reserved some space in the structure for that purpose</em> add it to the end: you are least likely to create compatibility problems that way.</p>n<p>If you&#8217;re adding to a collection of objects (as described above) the same applies: make it a complete structure (magic, version and all) and add it to the end.</p>n<p>If you&#8217;re designing a structure that is going to be part of a collection of structures communicated somewhere, make sure its size is a multiple of the largest primitive normally used &#8212; e.g. a multiple of eight bytes, or four bytes if you don&#8217;t go larger than 32-bit integers. This allows the structures, once read into appropriately-aligned memory, to be automatically appropriately aligned when accessed in that appropriately-aligned memory. Because most functions that dump data to the medium don&#8217;t pad structures (as the compiler does when you create an array of objects that don&#8217;t follow this rule) you won&#8217;t be able to count on alignment otherwise.</p>n<h2>Other bits<sup><a href="http://rlc.vlinder.ca/blog/2012/12/how-to-design-a-struct-for-storage-or-networking/#footnote_4_1966" id="identifier_4_1966" class="footnote-link footnote-identifier-link" title="I was going to call this section &ldquo;Optional bits&rdquo; but it&rsquo;s not really optional any more than the text itself implies &mdash; I don&rsquo;t want you to skip over this section just because I said it was optional">5</a></sup></h2>n<p>If the data you are dumping is somehow variable-sized (i.e. it&#8217;s the header of something), <em>please include the size</em> so we know how much data to skip. If need be the size can be used in <i>lieu</i> of a version (as one Redmond-based company often does).</p>n<p>You may want to include a few reserved fields for future use. <em>Do</em> expect them to be 0 by default, or include some kind of flag when set to 0 if the 0 means something, and <em>please do</em> <code>memset</code> structures to 0 before filling them in because you <em>will</em> forget some of the fields some of the time, and you don&#8217;t want random values to end up in there.</p>n<p>Don&#8217;t use already-common magic numbers, such as <code>0xfeeefeee</code> or <code>0xcccccccc</code> etc. While they&#8217;re easy to recognize and perfectly fine as magic numbers in their own right, encountering them usually means <blink><strong>bug</strong></blink> and really stands out to they hardened debugger&#8217;s eye.</p>n<p>If your structure contains strings, try to zero-terminate them if at all possible. Many, many programmers forget to check for zero-termination when they output something from the struct, which causes many, many crashes or other random behaviors.</p>n<h2>Reading and writing</h2>n<p>Writing is the easy part, so let&#8217;s start with that.</p>n<p>If you have a structure in memory, writing it somewhere is simply a case of calling the appropriate <code>write()</code> function passing it a pointer to your structure and the size, like this:n<pre>retval = write(&data, sizeof(data));</pre>n<p> You don&#8217;t have to worry too much about issues such as alignment, because the write function will ready the thing byte by byte if need be.</p>n<p>Reading it into memory is another matter: while in most cases you still don&#8217;t need to worry about alignment, you just might have to if the reading function hands you a pointer rather than the other way around: it may not be aligned properly, so you can&#8217;t just cast it to the type you want. In stead, use <code>memcpy</code> to copy the data into a temporary variable of the right type, so the compiler can align it properly for you.</p>n<p>Also use the version information you stored to know what the size of the data you received is &#8211; it may be different from what you were expecting as the structure may have grown since you wrote your code, or since the code that sent the data was written. Version information will also tell you something about the meaning of the contents of the structure, which may have changed or may need to be set to some default value if it wasn&#8217;t provided before.</p>n<p>So, reading data &#8212; even binary data &#8212; from any kind of storage or communications medium is really <em>parsing</em>: you should carefully design how it&#8217;s done and keep in mind that things change over time: some intern may change the code one day having neither read this post nor anything else useful to his job. While there is only so much you can do to protect yourself from that particular intern, you can at least try to be graceful about erroring out when you encounter one of his bugs.</p>n<p>HTH</p>n<p>rlc</p>nn<ol class="footnotes"><li id="footnote_0_1966" class="footnote">and I include writing to persistent storage and reading it back later in &#8220;communication&#8221; because that&#8217;s what it is: the software reading the data may very well be different from the software writing it &#8212; be it different versions of the same software, or different software altogether</li><li id="footnote_1_1966" class="footnote">There is some religious debate over whether or not to do <code>typedef struct Version_struct Version;</code> in C headers, so I left that out, though I usually would have included it for convenience.</li><li id="footnote_2_1966" class="footnote">At least, there is on the vast majority of platforms</li><li id="footnote_3_1966" class="footnote">In other words: just don&#8217;t use it &#8212; it&#8217;s useless.</li><li id="footnote_4_1966" class="footnote">I was going to call this section &#8220;Optional bits&#8221; but it&#8217;s not really optional any more than the text itself implies &#8212; I don&#8217;t want you to skip over this section just because I said it was optional</li></ol>"
post_title: "How to design a struct for storage or communicating"
post_excerpt: "One of the most common ways of &ldquo;persisting&rdquo; or communicating data in an embedded device is to just dump it into persistent storage or onto the wire: rather than generating XML, JSON or some other format which would later have &hellip; <a href="http://rlc.vlinder.ca/blog/2012/12/how-to-design-a-struct-for-storage-or-networking/">Continue reading <span>&rarr;</span></a>"
post_status: "inherit"
comment_status: "closed"
ping_status: "closed"
post_password: ""
post_name: "32-revision-v1"
to_ping: ""
pinged: ""
post_modified: "2012-12-04 22:21:06"
post_modified_gmt: "2012-12-05 02:21:06"
post_content_filtered: ""
post_parent: 32
guid: "http://feedwordpress.radgeek.com/?rev=5f14bf24bc6fbf7a8036333128c51754"
menu_order: 0
post_type: "revision"
post_mime_type: ""
comment_count: 0
