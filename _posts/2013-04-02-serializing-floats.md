---
layout: post
title: "Serializing floats"
date: 2013-04-02 19:47:14
categories: blog
---
Serializing is the act of taking a chunk of data an converting it to something that can be communicated -- i.e. some format or other that someone or something else can parse and understand. You do it all the time when you write, or even when you talk: you serialize your thoughts as words that you then serialize as either characters on paper (virtual or dead tree) or as sound.rnrnParsing is the opposite process of serializing -- also called deserializing.rnr rnrnAs with words on paper, there is some inaccuracy in serializing when it's floating point numbers being serialized in human-readable form. That is because a computer uses a binary system for counting while a human uses a decimal system. For integers, that doesn't matter because any integer value that can be represented in, say, 32 bits can also be represented in 10 decimal characters and the conversion is fairly straight-forward.rnrnThe same is not true of floating point values: due to the way floats are implemented, there are some numbers that simply ca ot be accurately represented in a `float` (the same goes for `double`s, of course).rnrnFloating point numbers consist of three parts: the sign (plus or minus), the mantissa and the exponent. The value is [latex]V=S*M*10^E[/latex] in which [latex]S[/latex] is 1 for positive and -1 for negative, [latex]M[/latex] the mantissa and [latex]E[/latex] the exponent. For example, in the case of -12.345 [latex]S = -1[/latex], [latex]E = 1[/latex] and [latex]M = 1.2345[/latex].rnrnUnderstanding this, we can implement a function to split a floating-point value into its constituent parts: ```cpp void split_float(rn int *signrn , double *mantissarn , int *exponentrn , double valuern )rn{rn pre_conditio (sign && mantissa && exponent);rn if (value < 0)rn {rn *sign = -1;rn value = -value;rn }rn elsern {rn *sign = 1;rn }rn *exponent = (int)log10(value);rn *mantissa = value / pow(10, *exponent);rn} ``` rnIn this code, the first thing we take care of is the sign. Note that we also change the sign of `value` in that case, because `log10` of a negative number doesn't work.rnrnTo get the exponent, we call `log10` on the (now positive) value and round it off. Whether casting to `int` rounds up or down depends on the machine you run it on (mostly), but it usually tends to round down.rnrnTo get the mantissa, [latex]M[/latex] we do this: [latex]M=\frac{{\lvert}V{\rvert}}{10^E}[/latex] which is equivalent to hacking off the exponent part of the value, leaving only the mantissa.rnrnNow, if we want to serialize this into a `char` buffer, we can write a function like this: ```cpp int serialize(rn char *outrn , unsigned int out_sizern , double valuern )rn{rn pre_conditio (out || !out_size);rn int s, e, dotted = 0, outputting = 0, characters = 0;rn split_float(&s;, &value;, &e;, value);rn if (out_size && (-1 == s))rn {rn *out++ = '-';rn --out_size;rn }rn elsern { /bin /boot /cdrom /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /libx32 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old not negative */ }rnrn while (out_size && value && (characters < 15))rn {rn *out++ = '0' + (int)value;rn --out_size;rn value -= (int)value;rn value *= 10;rn ++characters;rn if (value && out_size && !dotted)rn {rn *out++ = '.';rn --out_size;rn dotted = 1;rn }rn elsern { /bin /boot /cdrom /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /libx32 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old already dotted or no space for the dot */ }rn }rn if (out_size && e)rn {rn *out++ = 'e';rn --out_size;rn if ((e < 0) && out_size)rn {rn *out++ = '-';rn e = -e;rn }rn if (out_size && (e / 100))rn {rn *out++ = '0' + (e / 100);rn --out_size;rn outputting = 1;rn }rn elsern { /bin /boot /cdrom /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /libx32 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old no more space or nothing to output */ }rn e = e % 100;rn if (outputting || (out_size && (e / 10)))rn {rn *out++ = '0' + (e / 10);rn --out_size;rn outputting = 1;rn }rn elsern { /bin /boot /cdrom /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /libx32 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old no more space or nothing to output */ }rn e = e % 10;rn if (outputting || (out_size && e))rn {rn *out++ = '0' + e;rn --out_size;rn }rn elsern { /bin /boot /cdrom /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /libx32 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old no more space or nothing to output */ }rn }rn elsern { /bin /boot /cdrom /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /libx32 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old no exponent or no more space */ }rn if (out_size) *out = 0;rn return (int)--out_size;rn} ``` rnrnThere are a few interesting details in this piece of code. Look, for example, how it handles the size of the output buffer: it only writes to `*out` one character at a time and only if `out_size` is greater than 0. Note, though, that it decrements `out_size` unconditionally on the last line. This has the effect of returning the number of bytes remaining in the output buffer on success (which will be >= 0) or -1 on error.rnrnSimilarly, we know that a `double` can't have an exponent of more than three characters, so in stead of taking [latex]E \mod 10[/latex] and repeatedly dividing [latex]E[/latex] by 10, then inverting the generated characters (which is the way integers are usually serialized) we just check hundreds, tens and units like a human would normally do.rnrnLikewise, we know that by dividing [latex]{\lvert}V{\rvert}[/latex] by [latex]10^E[/latex] we are left with [latex]0 \leq M < 10[/latex], so we have one digit before the dot. We can then output the dot immediately after the first digit, unless there's nothing more to output.rnrnThere's a few other trivial details that new programmers may want to look at -- here's some code to run it with: ```cpp int mai (void)rn{rn char buffer[100];rn assert(serialize(buffer, sizeof(buffer), -1) == 97);rn assert(strcmp("-1", buffer) == 0);rn printf("%s ", buffer);rn rn #define TEST(a) \rn assert(serialize(buffer, sizeof(buffer), a) > 0); \rn printf("%s -> %s ", #a, buffer); rn TEST(0.43141910996070e8);rn TEST(-0.4948270426510e51);rn TEST(0.8017058961133e32);rn TEST(-0.6431647334000e-50);rn TEST(0.62050295608660e-7);rn TEST(-0.7980292076396e43);rn TEST(0.8098012295643e-42);rn TEST(-0.235788271940e84);rn TEST(0.5378916319145e93);rn TEST(-0.83169954137327e-3);rn rn return 0;rn} ```