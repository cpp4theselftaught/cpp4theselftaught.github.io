---
layout: post
title: "A few final words on functional programming"
date: 2011-08-05 14:59:38
categories: blog
---
n n n n n n n  n  n  The previous two installments of C++ for the self-taught were both about functional programming. Before we get back to Chausette, I’ll put in a few final words on the topic, combining both run-time functional programming with compile-time functional programming and, while we’re at it, language and meta-language design.

This is fun stuff, but if you want to understand everything I will talk about in this installment you’ll have a bit of studying to do. In the code I will present in this installment we will use: 

  * symbol tables
  * parsers
  * expression templates
  * the Backus-Naur Form (BNF)
  * iterators
  * the Factory Method patter 

  
A few days ago, I received a message over Twitter by @[pauldoo](http://twitter.com/pauldoo "@paultoo"):  
  

I was already pondering what I might put in the “few final words on functional programming” post and I like to lend a helping hand when I can, so I decided to do just that when he sent me a follow-up E-mail.

## Grammar & BNF

What he wanted to do is parse expressions in a lisp-y functional language. To do that, he had defined a simple grammar that, in BNF, would look a bit like this:

```bnf expression ::= ( list ) list ::= list_item+nlist_item ::= STRING | DOUBLE | expressio ``` 

To see the _Aside_ click here.To hide the _Aside_ click here.

BNF is the Backus-Naur Form. It is a standard way of writing up the grammar of a language

BNF consists of _terminals_ , which are tokens, and _on-terminals_ which are groups of tokens that, together, have a meaning. In this grammar, the terminals are `(` and `)` — the parenthesis characters — and the multi-character `STRING` and `DOUBLE` tokens. Strings are basically sequences of ASCII characters whereas doubles are what you would normally expect a C compiler to interpret as a floating-point constant.

The non-terminals in this grammar are `list`, which consists of one or more `list_item`s; `list_item`, which is either a string, a double, or an expression, and `expressio `, which is a list between parentheses.

Note that the grammar _doesn’t_ tell you that the strings in the grammar are intended to be function names and the doubles are intended to be constants. In that sense, the language being described here is a lot like the original version of [Funky](http://funky.vlinder.ca/ "The Funky Functional Embeddable programming language").

When you want to write a parser for something, you first have to have a good grasp of two important things: the first is the grammar, which we’ve just discussed; the second is what the grammar means. In this case, what the grammar means is that we have some kind of operator — which is the first thing after the opening parenthesis — which is followed by whatever it operates on: a possibly-empty list of values and expressions. Those expressions could be recursively evaluated and the results of those evaluations used as values in the surrounding expression, such that `(+ 1 (+ 1 1))` becomes equivalent to `(+ 1 2)` which in turn becomes equivalent to `3`, so there is no need to treat expressions any differently from other values, where the surrounding expression is concerned.

That means that we can model the expression itself as follows:

```cpp struct Expressio ; typedef variant< double, Expression > ListItem; typedef vector< ListItem > List; struct Expression { Operator operator_; List list_; }; ``` 

That is: an expression consists of an _operator_ and a _list_ of operands. Each one of those operands is either a `double` or an `Expressio `. While we’re at it, we might as well include strings and integers in the mix of possible operands — so as to make our new little language a bit more useful — and model a ListItem as `typedef variant< int, double, string, Expression > ListItem;`

## Evaluating an expressio 

Now, evaluating an expression becomes a question of evaluating any sub-expressions until only values are left, and then applying the right operator to those values. This is typical of functional programming: recursion.

Let’s say we define four operators for now: plus, minus, multiply and divide. We also have three primitive types: integers, doubles and strings. That means we have up to twelve functions to implement – one for each combination of operator and type. We’ll only implement them if they make sense, though, so we won’t multiply or divide strings. 

To see the _Aside_ click here.To hide the _Aside_ click here.

Note, by the way, that we don’t have expressions as “primitive types” here: by the time we will want to apply the operators to the operands, the sub-expressions will all have been evaluated.

The following chunk of code is rather long, but it does the evaluation of an expression:

```cpp ListItem evaluate(Expression &expressio; ) { ListItemType result_type(int__); ListItem retval; // first pass: evaluate any sub-expressions for (List::iterator iter(expression.list_.begi ()); iter != expression.list_.end(); ++iter) { if (iter->which() == expression__) { *iter = evaluate(get< Expression >(*iter)); } switch (iter->which()) { case int__ : // this is the default type - it doesn't change anything break; case double__ : if (result_type == int__) { result_type = double__; } else { /* either already a double, or it's a string */ } break; case string__ : result_type = string__; break; default : throw logic_error("unexpected operand type"); } } switch (result_type) { case int__ : // nothing to do in this case: this is the default for the variant, and it will be zero-initialized break; case double__ : retval = 0.0; break; case string__ : retval = string(); break; default : throw logic_error("Unexpected result type"); } boost::shared_ptr< Accumulator > accumulator = getAccumulator(retval, expression.operator_, result_type); for (List::const_iterator iter(expression.list_.begi ()); iter != expression.list_.end(); ++iter) { (*accumulator)(*iter); } n retur retval; } ``` 

In lines 6 through 31 of this code, all the sub-expressions are evaluated (lines 8 through 11) and the return type of the current expression is determined. Basically that determination goes like this: if all the operands are integers, the return type is an integer. If one or more of the operands is a `double` (and none are strings, so the operands are a mix of integers and doubles with at least done double), the return type is a `double`. If any of the operands is a string, the return type is a string.

In lines 32 to 45, the result value is initialized according to its determined type: either an integer zero, a floating-point zero or an empty string.

In line 46, we call a factory method to get the accumulator functor. We will look into that a little later.

In lines 47 through 50, the accumulator functor is called for every operands of the current operator. The result of this is transparently stored in `retval`, which is returned in line 52.

## The Factory Method

The Factory Method is an often-used design pattern which allows you to implement a factory as a single function. In our case, we could have done this a bit more eloquently that I actually did — so feel free to optimize.

Here’s the code, including the `Accumulator` class:

```cpp struct Accumulator { virtual ~Accumulator() {} n virtual Accumulator* create(ListItem &result;) const = 0; n const Accumulator& operator()(const ListItem &list;_item) const { call_(list_item); retur *this; } n ListItem operator*() const { retur *result_; } protected : virtual void call_(const ListItem &list;_item) const = 0; n Accumulator() : result_(0) , first_(true) { /* no-op */ } n n Accumulator(ListItem &result;) : result_(&result;) , first_(true) { /* no-op */ } n ListItem *result_; mutable bool first_; }; template < Operator operator_type__, ListItemType return_type__ > struct Accumulator_ : Accumulator { private : Accumulator_() { /* no-op */ } n Accumulator_(ListItem &result;) : Accumulator(result) { /* no-op */ } n Accumulator_* create(ListItem &result;) const { retur ew Accumulator_(result); } protected : /*virtual */void call_(const ListItem &list;_item) const/* = 0*/ { if (first_) { switch (result_->which()) { case int__ : *result_ = cast< int__ >(list_item); break; case double__ : *result_ = cast< double__ >(list_item); break; case string__ : *result_ = cast< string__ >(list_item); break; } first_ = false; } else { *result_ = Operator_< operator_type__, return_type__ >::apply(*result_, list_item); } } n friend boost::shared_ptr< Accumulator > getAccumulator(ListItem &result;, Operator operator_type, ListItemType return_type); }; nboost::shared_ptr< Accumulator > getAccumulator(ListItem &result;, Operator operator_type, ListItemType return_type) { static Accumulator_< plus__, int__ > pi_accumulator__; static Accumulator_< plus__, double__ > pd_accumulator__; static Accumulator_< plus__, string__ > ps_accumulator__; static Accumulator_< minus__, int__ > mi_accumulator__; static Accumulator_< minus__, double__ > md_accumulator__; static Accumulator_< minus__, string__ > ms_accumulator__; static Accumulator_< multiply__, int__ > ui_accumulator__; static Accumulator_< multiply__, double__ > ud_accumulator__; static Accumulator_< divide__, int__ > di_accumulator__; static Accumulator_< divide__, double__ > dd_accumulator__; static Accumulator* accumulators__[operator_count__][list_item_type_count__] = { { π_accumulator__, &pd;_accumulator__, &ps;_accumulator__, 0 },n { &mi;_accumulator__, &md;_accumulator__, &ms;_accumulator__, 0 },n { &ui;_accumulator__, &ud;_accumulator__, 0, 0 },n { &di;_accumulator__, ⅆ_accumulator__, 0, 0 } }; n if (accumulators__[operator_type][return_type] != 0) { retur boost::shared_ptr< Accumulator >(accumulators__[operator_type][return_type]->create(result)); } else { if (operator_type == multiply__) { throw logic_error("Don't know how to multiply a string"); } else { throw logic_error("Don't know how to divide a string"); } } } ``` 

As you an see, there are ten `static` instances of accumulators inside the `getAccumulator` function. None of these is ever made available to a called, however, because none of them is capable of doing the job of an `Accumulator`. That’s because they don’t have a valid value in the `result_` member, which they need to accumulate into.

The `getAccumulator` function assumes that it won’t be called for any non-existent operators or list-item types and that it won’t be called for divisions or multiplications of strings. It will attempt to diagnose the latter condition, but in any case it will throw a `logic_error` when it is called incorrectly.

Of course, what this really does is map a dynamic type to a static one: the ten instances are pointed to by an array of pointers, from which the appropriate one is taken according to the parameters passed to the function. That instance creates a new instance of its own type which, in turn, can be used as a real accumulator.

## Traits and policies

Once we have a static type, we should no longer need to bother finding out what to do with the types we need. That means that we should now be able to use C++’s type system to find out how to implement a given operator for the types we’d been given earlier. We do that with a policy class, that looks like this:

```cpp template < Operator operator__, ListItemType return_type__ > struct Operator_; ``` 

We will need a specialization for every valid combination of operator and return type, which means we need ten policies in total:

```cpp template <> struct Operator_< plus__, int__ >; template <> struct Operator_< plus__, double__ >; template <> struct Operator_< plus__, string__ >; template <> struct Operator_< minus__, int__ >; template <> struct Operator_< minus__, double__ >; template <> struct Operator_< minus__, string__ >; template <> struct Operator_< divide__, int__ >; template <> struct Operator_< divide__, double__ >; template <> struct Operator_< multiply__, int__ >; template <> struct Operator_< multiply__, string__ >; ``` 

Each of these can assume that the left-hand-side operand is already of the right type, but may potentially have to cast the right-hand side — except for the ones that deal with integers, which always have integers on both sides. That means we need something to cast our variants — something that looks like this: ``` template < ListItemType target_list_item_type__ > unspecified cast(const ListItem & list_item); ``` 

The caveat is, ofcourse, the “unspecified” bit: we need to tell the compiler which type `cast` will return for each `ListItemType` value. We can easily do that with a little meta-function:

```cpp template < ListItemType target_list_item_type__ > struct get_cast_target_type; template <> struct get_cast_target_type< int__ > { typedef int type; }; template <> struct get_cast_target_type< double__ > { typedef double type; }; template <> struct get_cast_target_type< string__ > { typedef string type; }; ``` 

This means that we can now declare the `cast` function as follows:

```cpp template < ListItemType target_list_item_type__ > /*unspecified*/typename get_cast_target_type< target_list_item_type__ >::type cast(const ListItem & list_item); ``` 

and specialize it like this:

```cpp template < > int cast< int__ >(const ListItem & list_item) { assert(list_item.which() == int__); retur get< int >(list_item); } template < > double cast< double__ >(const ListItem & list_item) { assert((list_item.which() == int__) || (list_item.which() == double__)); if (list_item.which() == double__) { retur get< double >(list_item); } else { retur static_cast< double >(get< int >(list_item)); } } template < > string cast< string__ >(const ListItem & list_item) { assert(list_item.which() != expression__); if (list_item.which() == string__) { retur get< string >(list_item); } else if (list_item.which() == int__) { retur lexical_cast< string >(get< int >(list_item)); } else { assert(list_item.which() == double__); retur lexical_cast< string >(get< double >(list_item)); } } ``` 

## Writing the parser

Now that we know what we want to parse _into_ — an expression — we can decide how to parse. We already have the grammar, so we can now try to express it in code.

[Boost.Spirit](http://spirit.sf.net/ "Boost Spirit project page") is a template library that allows you to generate parsers from a BNF-like meta-language expressed in C++. It uses expression templates extensively to allow you to put BNF in your code and generate a parser from that code.

To see the _Aside_ click here.To hide the _Aside_ click here.

Let’s first have a closer look at the BNF we will want to express: it has changed a bit since the begi ing of this post as we’re no longer looking strictly at what @pauldoo wanted to achieve with his grammar. The new grammar now looks a bit like this: ``` expression ::= ( OPERATOR list ) list ::= list_item+nlist_item ::= expressio | INTEGERn | DOUBLEn | STRING ``` 

An `OPERATOR` is one of the following characters: `+` `-` `*` `/`; and a `STRING` is a double quote, followed by zero or more escaped characters (\a, \b, \f, , \r, \t, \v, \\\, \’, \”) or hex characters (\xHH where HH is a hexadecimal code) or characters that are not double quotes; followed by a double quote; an `INTEGER` is one or more numerical characters; and a `DOUBLE` is zero or more numerical characters followed by a dot followed by one or more numerical characters.

The fun thing with Boost.Spirit is that you can express something like this directly in code:

```cpp expression_ = '(' >> operator_ >> list_ >> ')' ; operator_.add ("+", plus__) ("-", minus__) ("*", multiply__) ("/", divide__) ; list_ = +list_item_n ; list_item_ = expression_n | qi::int_ | qi::double_ | string_n ; string_ = lexeme['"' >> *(unescape_char_ | ("\\\x" >> qi::hex) | (qi::char_ - qi::char_('"'))) >> '"'] ; unescape_char_.add ("\\\a", '\a')("\\\b", '\b')("\\\f", '\f')("\\\ ", ' ') ("\\\r", '\r')("\\\t", '\t')("\\\v", '\v')("\\\\\\\", '\\\') ("\\\\\'", '\'')("\\\\\"", '\"'); ``` 

As you can see, Boost.Spirit must have overloaded a ton of operators to be able to do this. The point is, though, that with only very little additional boilerplate code (we have to declare the variables being used here) we have a working parser.

Note that both `operator_` and `unescape_char_` are _symbol tables_ : they map a given character or string value to another value, possibly of a different type. Also note that each of these parsers provides an analogous structure as a result of its parse (if successful), so `list_` yields a `vector< ListItem >`, a.k.a. a `List`; `string_` yields a `std::string`, etc.

So, here’s all of the code of a parser and evaluator for the little language we’ve just designed: [on IDEOne.com](http://ideone.com/iJYEV "Code on IDEOne.com")

Show codehide code

```cpp /* Copyright (c) 2011, Ronald Landheer-Cieslak n 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml All rights reserved.n 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml n 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml Redistribution and use in source and binary forms, with or withoutn 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml modification, are permitted provided that the following conditions are met:n 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml Redistributions of source code must retain the above copyrightn 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml notice, this list of conditions and the following disclaimer.n 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml Redistributions in binary form must reproduce the above copyrightn 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml notice, this list of conditions and the following disclaimer in then 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml documentation and/or other materials provided with the distribution.n 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml Neither the name of the Vlinder Software nor the name of Ronald n 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml Landheer-Cieslak names of its contributors may be used to endorse or n 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml promote products derived from this software without specific prior n 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml written permission.n 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml n 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" ANDn 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIEDn 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE AREn 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml DISCLAIMED. IN NO EVENT SHALL RONALD LANDHEER-CIESLAK BE LIABLE FOR ANYn 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGESn 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;n 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED ANDn 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORTn 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THISn 2017-10-14-new-website.md 2017-10-14-new-website.md~ split.sh split.sh~ wp_post_10.txt wp_post_11.txt wp_post_12.txt wp_post_13.txt wp_post_14.txt wp_post_15.txt wp_post_16.txt wp_post_17.txt wp_post_18.txt wp_post_19.txt wp_post_1.yml wp_post_20.txt wp_post_21.txt wp_post_22.txt wp_post_23.txt wp_post_24.txt wp_post_25.txt wp_post_26.txt wp_post_27.txt wp_post_28.txt wp_post_29.txt wp_post_2.txt wp_post_30.txt wp_post_31.txt wp_post_3.txt wp_post_4.txt wp_post_5.txt wp_post_6.txt wp_post_7.txt wp_post_8.txt wp_post_9.txt wp_posts.yml SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGEn */ #include  #include  #include  #include  #include  #include  #include  #include  amespace qi = boost::spirit::qi; amespace ascii = boost::spirit::ascii; using amespace std; using amespace boost; enum Operator { plus__,n minus__,n multiply__,n divide__,n operator_count__ }; enum ListItemType { int__,n double__,n string__,n expression__,n list_item_type_count__ }; struct Expressio ; typedef variant< int, double, string, Expression > ListItem; typedef vector< ListItem > List; struct Expression { Operator operator_; List list_; }; BOOST_FUSION_ADAPT_STRUCT( Expression,n (Operator, operator_) (List, list_) ) template < ListItemType target_list_item_type__ > struct get_cast_target_type; template <> struct get_cast_target_type< int__ > { typedef int type; }; template <> struct get_cast_target_type< double__ > { typedef double type; }; template <> struct get_cast_target_type< string__ > { typedef string type; }; template < ListItemType target_list_item_type__ > /*unspecified*/typename get_cast_target_type< target_list_item_type__ >::type cast(const ListItem & list_item); template < > int cast< int__ >(const ListItem & list_item) { assert(list_item.which() == int__); retur get< int >(list_item); } template < > double cast< double__ >(const ListItem & list_item) { assert((list_item.which() == int__) || (list_item.which() == double__)); if (list_item.which() == double__) { retur get< double >(list_item); } else { retur static_cast< double >(get< int >(list_item)); } } template < > string cast< string__ >(const ListItem & list_item) { assert(list_item.which() != expression__); if (list_item.which() == string__) { retur get< string >(list_item); } else if (list_item.which() == int__) { retur lexical_cast< string >(get< int >(list_item)); } else { assert(list_item.which() == double__); retur lexical_cast< string >(get< double >(list_item)); } } template < Operator operator__, ListItemType return_type__ > struct Operator_; template <> struct Operator_< plus__, int__ > { static ListItem apply(ListItem lhs, ListItem rhs) { assert(lhs.which() == int__); assert(rhs.which() == int__); get< int >(lhs) += get< int >(rhs); retur lhs; } }; template <> struct Operator_< plus__, double__ > { static ListItem apply(ListItem lhs, ListItem rhs) { get< double >(lhs) += cast< double__ >(rhs); retur lhs; } }; template <> struct Operator_< plus__, string__ > { static ListItem apply(ListItem lhs, ListItem rhs) { string r = cast< string__ >(rhs); string &l; = get< string >(lhs); l.insert(l.end(), r.begi (), r.end()); retur lhs; } }; template <> struct Operator_< minus__, int__ > { static ListItem apply(ListItem lhs, ListItem rhs) { assert(lhs.which() == int__); assert(rhs.which() == int__); get< int >(lhs) -= get< int >(rhs); retur lhs; } }; template <> struct Operator_< minus__, double__ > { static ListItem apply(ListItem lhs, ListItem rhs) { get< double >(lhs) -= get< double >(rhs); retur lhs; } }; template <> struct Operator_< minus__, string__ > { static ListItem apply(ListItem lhs, ListItem rhs) { using boost::algorithm::erase_first; n string r = cast< string__ >(rhs); string &l; = get< string >(lhs); erase_first(l, r); retur lhs; } }; template <> struct Operator_< divide__, int__ > { static ListItem apply(ListItem lhs, ListItem rhs) { assert(lhs.which() == int__); assert(rhs.which() == int__); get< int >(lhs) /= get< int >(rhs); retur lhs; } }; template <> struct Operator_< divide__, double__ > { static ListItem apply(ListItem lhs, ListItem rhs) { get< double >(lhs) /= cast< double__ >(rhs); retur lhs; } }; template <> struct Operator_< multiply__, int__ > { static ListItem apply(ListItem lhs, ListItem rhs) { assert(lhs.which() == int__); assert(rhs.which() == int__); get< int >(lhs) *= get< int >(rhs); retur lhs; } }; template <> struct Operator_< multiply__, double__ > { static ListItem apply(ListItem lhs, ListItem rhs) { get< double >(lhs) *= cast< double__ >(rhs); retur lhs; } }; struct Accumulator { virtual ~Accumulator() {} n virtual Accumulator* create(ListItem &result;) const = 0; n const Accumulator& operator()(const ListItem &list;_item) const { call_(list_item); retur *this; } n ListItem operator*() const { retur *result_; } protected : virtual void call_(const ListItem &list;_item) const = 0; n Accumulator() : result_(0) , first_(true) { /* no-op */ } n n Accumulator(ListItem &result;) : result_(&result;) , first_(true) { /* no-op */ } n ListItem *result_; mutable bool first_; }; template < Operator operator_type__, ListItemType return_type__ > struct Accumulator_ : Accumulator { private : Accumulator_() { /* no-op */ } n Accumulator_(ListItem &result;) : Accumulator(result) { /* no-op */ } n Accumulator_* create(ListItem &result;) const { retur ew Accumulator_(result); } protected : /*virtual */void call_(const ListItem &list;_item) const/* = 0*/ { if (first_) { switch (result_->which()) { case int__ : *result_ = cast< int__ >(list_item); break; case double__ : *result_ = cast< double__ >(list_item); break; case string__ : *result_ = cast< string__ >(list_item); break; } first_ = false; } else { *result_ = Operator_< operator_type__, return_type__ >::apply(*result_, list_item); } } n friend boost::shared_ptr< Accumulator > getAccumulator(ListItem &result;, Operator operator_type, ListItemType return_type); }; nboost::shared_ptr< Accumulator > getAccumulator(ListItem &result;, Operator operator_type, ListItemType return_type) { static Accumulator_< plus__, int__ > pi_accumulator__; static Accumulator_< plus__, double__ > pd_accumulator__; static Accumulator_< plus__, string__ > ps_accumulator__; static Accumulator_< minus__, int__ > mi_accumulator__; static Accumulator_< minus__, double__ > md_accumulator__; static Accumulator_< minus__, string__ > ms_accumulator__; static Accumulator_< multiply__, int__ > ui_accumulator__; static Accumulator_< multiply__, double__ > ud_accumulator__; static Accumulator_< divide__, int__ > di_accumulator__; static Accumulator_< divide__, double__ > dd_accumulator__; static Accumulator* accumulators__[operator_count__][list_item_type_count__] = { { π_accumulator__, &pd;_accumulator__, &ps;_accumulator__, 0 },n { &mi;_accumulator__, &md;_accumulator__, &ms;_accumulator__, 0 },n { &ui;_accumulator__, &ud;_accumulator__, 0, 0 },n { &di;_accumulator__, ⅆ_accumulator__, 0, 0 } }; n if (accumulators__[operator_type][return_type] != 0) { retur boost::shared_ptr< Accumulator >(accumulators__[operator_type][return_type]->create(result)); } else { if (operator_type == multiply__) { throw logic_error("Don't know how to multiply a string"); } else { throw logic_error("Don't know how to divide a string"); } } } void ping() { cout << "ping" << endl; } template < typename Iterator > struct Grammar : qi::grammar< Iterator, Expressio (), ascii::space_type > { Grammar() : Grammar::base_type(expression_) { using qi::_val; using qi::_1; using phoenix::push_back; using qi::lexeme; n expression_ = '(' >> operator_ >> list_ >> ')' ; operator_.add ("+", plus__) ("-", minus__) ("*", multiply__) ("/", divide__) ; list_ = +list_item_n ; list_item_ = expression_n | qi::int_ | qi::double_ | string_n ; string_ = lexeme['"' >> *(unescape_char_ | ("\\\x" >> qi::hex) | (qi::char_ - qi::char_('"'))) >> '"'] ; unescape_char_.add ("\\\a", '\a')("\\\b", '\b')("\\\f", '\f')("\\\ ", ' ') ("\\\r", '\r')("\\\t", '\t')("\\\v", '\v')("\\\\\\\", '\\\') ("\\\\\'", '\'')("\\\\\"", '\"'); n } n qi::rule< Iterator, Expressio (), ascii::space_type > expression_; qi::rule< Iterator, List(), ascii::space_type > list_; qi::rule< Iterator, ListItem(), ascii::space_type > list_item_; qi::rule< Iterator, string(), ascii::space_type > string_; qi::symbols< char const, char const > unescape_char_; qi::symbols< char const, Operator > operator_; }; nListItem evaluate(Expression &expressio; ) { ListItemType result_type(int__); ListItem retval; // first pass: evaluate any sub-expressions for (List::iterator iter(expression.list_.begi ()); iter != expression.list_.end(); ++iter) { if (iter->which() == expression__) { *iter = evaluate(get< Expression >(*iter)); } switch (iter->which()) { case int__ : // this is the default type - it doesn't change anything break; case double__ : if (result_type == int__) { result_type = double__; } else { /* either already a double, or it's a string */ } break; case string__ : result_type = string__; break; default : throw logic_error("unexpected operand type"); } } switch (result_type) { case int__ : // nothing to do in this case: this is the default for the variant, and it will be zero-initialized break; case double__ : retval = 0.0; break; case string__ : retval = string(); break; default : throw logic_error("Unexpected result type"); } boost::shared_ptr< Accumulator > accumulator = getAccumulator(retval, expression.operator_, result_type); for (List::const_iterator iter(expression.list_.begi ()); iter != expression.list_.end(); ++iter) { (*accumulator)(*iter); } n retur retval; } n int mai () { using boost::spirit::ascii::space; n Expression expressio ; Grammar< string::const_iterator > grammar; string test("(+ 1 (+ 1 1.2))"); string::const_iterator iter = test.begi (); string::const_iterator end = test.end(); if (qi::phrase_parse(iter, end, grammar, space, expressio )) { assert(expression.operator_ == plus__); ListItem result(evaluate(expressio )); assert(result.which() == double__); assert(get< double >(result) == 3.2); } else { assert(!"parse failed"); } test = "(* 1 2)"; iter = test.begi (); end = test.end(); expression.list_.clear(); if (qi::phrase_parse(iter, end, grammar, space, expressio )) { assert(expression.operator_ == multiply__); ListItem result(evaluate(expressio )); assert(result.which() == int__); assert(get< int >(result) == 2); } else { assert(!"parse failed"); } test = "(+ \"Hello, \" \"world!\")"; iter = test.begi (); end = test.end(); expression.list_.clear(); if (qi::phrase_parse(iter, end, grammar, space, expressio )) { assert(expression.operator_ == plus__); ListItem result(evaluate(expressio )); assert(result.which() == string__); assert(get< string >(result) == "Hello, world!"); } else { assert(!"parse failed"); } test = "(+ \"Goodbye\" (- \"Hello, world!\" \"Hello\"))"; iter = test.begi (); end = test.end(); expression.list_.clear(); if (qi::phrase_parse(iter, end, grammar, space, expressio )) { assert(expression.operator_ == plus__); ListItem result(evaluate(expressio )); assert(result.which() == string__); assert(get< string >(result) == "Goodbye, world!"); } else { assert(!"parse failed"); } } ``` 

n